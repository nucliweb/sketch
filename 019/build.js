!function n(e,t,o){function i(a,s){if(!t[a]){if(!e[a]){var c="function"==typeof require&&require;if(!s&&c)return c(a,!0);if(r)return r(a,!0);var v=new Error("Cannot find module '"+a+"'");throw v.code="MODULE_NOT_FOUND",v}var l=t[a]={exports:{}};e[a][0].call(l.exports,function(n){var t=e[a][1][n];return i(t||n)},l,l.exports,n,e,t,o)}return t[a].exports}for(var r="function"==typeof require&&require,a=0;a<o.length;a++)i(o[a]);return i}({1:[function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),r=n("glslify"),a=r(["precision highp float;\n#define GLSLIFY 1\n\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform sampler2D texture1;\n\nvarying vec2 vUv;\nuniform float time;\n\nuniform sampler2D tMatCap;\nuniform sampler2D tMatCap2;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nuniform float scrollPer;\n\nvarying vec2 vN2;\nvarying vec3 e;\nvarying vec3 n;\n\nvoid main() {\n\n  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n//  vec2 vUv2 = vUv + vec2(0.0,time*0.1);\n//  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n  vec4 color = texture2D( texture1, vUv2 );\n//\n//  if( color.x <= 0.9 )discard;\n\n  vNormalMatrix;\n  vNormal;\n  vUv;\n\n  vec4 p = vec4( vPostion, 1. );\n  vec3 e = normalize( vec3( vModelViewMatrix * p ) );\n\n  vec3 n = normalize( vNormal );\n\n  vec3 r = reflect( e, n );\n  float m = 2. * sqrt(\n    pow( r.x, 2. ) +\n    pow( r.y, 2. ) +\n    pow( r.z + 1., 2. )\n  );\n  vec2 vN = r.xy / m + .5;\n\n  vec3 base;\n  base = texture2D( tMatCap, vN ).rgb;\n\n  gl_FragColor = vec4(base,1.0);\n\n//  float depth = gl_FragCoord.z / gl_FragCoord.w;\n//  float fogFactor = smoothstep( fogNear, fogFar, depth );\n//  gl_FragColor = mix( gl_FragColor, vec4( fogColor, 0.0 ), fogFactor );\n//  gl_FragColor = vec4( base, 1. );\n\n}"]),s=r(['#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_0(i);\n  vec4 p = permute_0( permute_0( permute_0(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x)\n{\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1(Pi0);\n  Pi1 = mod289_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1(permute_1(ix) + iy);\n  vec4 ixy0 = permute_1(ixy + iz0);\n  vec4 ixy1 = permute_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n\n#define PI 3.1415;\n\nuniform float time;\nuniform float scrollPer;\n\nvarying vec2 vUv;\n\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nvec3 sample(float t, float time) {\n  float angle = t * time * 2.0 * PI;\n  vec2 rot = vec2(cos(angle), sin(angle));\n  float z = t * 2.0 - 1.0;\n  return vec3(rot, z);\n}\n\nvec3 makeNose(vec3 pos){\n//  return  (pos);\n  return  (pos);// + cnoise3(pos)*0.3;\n//  if( pos.y >= scrollPer*2.0-1.0 )return pos;\n\n//  vec3 aaa = (pos) + (cnoise3((pos)*1.0 + time*0.8 )*0.4);// - sample(sin(position.y), sin(time) )*0.3 - vec3(0.0, yy, 0.0)*0.2 ) * yy;;\n//  if( aaa.y >= scrollPer*2.0-1.0 )return pos + ( normal * snoise3(pos + time*0.2 ) * 0.1);\n\n  //float yy = (0.0-pos.y);\n\n//  return pos + ( normal * 4.0 * snoise3(pos + time*0.4) * 0.3);\n//  return pos + ( normal * 2.0 * snoise3(pos * sin(time)) * 0.2) * (1.0 + sample(sin(position.z),sin(time)));\n//  return pos + (sample(position.z,sin(time) + 2.0)-1.0)*2.0;\n//  return pos + ( normal * 2.0 * snoise3(pos * (sin(time)+1.0)) * 0.2);// * (sample(position.z,sin(time) + 2.0)-1.0);\n//return pos + ( normal * 2.0 * snoise3(pos * (sin(time)+1.0)) * 0.2) - vec3(1.0,1.0,0.0) * cos(time*0.2)*2.0;// * (sample(position.z,sin(time) + 2.0)-1.0);\n//  return aaa;\n}\n\nvec3 getNeighbour(vec3 orig, float offsetT, float offsetP){\n\n  // xyz -> Spherical coordinates\n  float r = sqrt(orig.x*orig.x + orig.y*orig.y + orig.z*orig.z);\n  float theta = acos(orig.z/r);\n  float sgn = (orig.y>=0.?1.:-1.);\n  float phi = sgn * acos(orig.x/sqrt(orig.x*orig.x + orig.y*orig.y));\n\n  // add offset\n  theta += offsetT;\n  phi += offsetP;\n\n  // Spherical coordinates -> xyz\n  float x = r * sin(theta) * cos(phi);\n  float y = r * sin(theta) * sin(phi);\n  float z = r * cos(theta);\n\n  return vec3( x, y, z );\n  \n}\n\nvoid main() {\n\n  vUv = uv;\n//  vec3 pos = position + sample(position.z, sin(time) * 2.0) + position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) * 2.0 * tan(time)) * position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n\n//  vec3 pos = position + sample(position.z, sin(time*0.4) ) * ( normal * snoise3(position*1.0 + time*0.08 ));// + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3) + sample(position.z, 1.0 )*1.0;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);\n//  vec3 pos = position;// + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n\n  float dx = 0.001;\n  vec3 pos = makeNose( position + vec3(dx) );\n\n  // calculating two other positions with a small offset, then get the cross product.\n  // ref.) https://www.opengl.org/discussion_boards/showthread.php/165885-Question-about-calculating-vertex-normals?p=1173292&viewfull=1#post1173292\n  float gridOffset\t= 0.1;\n  vec3 neighbour1\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, gridOffset, 0.        ));\n  vec3 neighbour2\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, 0.        , gridOffset));\n\n  vec3 tangent\t= neighbour1 - pos;\n  vec3 bitangent= neighbour2 - pos;\n\n  vec3 norm\t= cross(normalize(tangent), normalize(bitangent));\n\tnorm\t\t= normalize(norm);\n\tnorm\t\t= normalMatrix * norm;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n\n//  vPostion = vec4(modelViewMatrix * vec4(pos,1.0)).xyz;\n  vPostion =  pos;\n\n//  vNormal = norm;\n  vNormal = normalMatrix * normal;\n  vModelViewMatrix = modelViewMatrix;\n  vNormalMatrix = normalMatrix;\n\n}']),c=function(){function n(e){o(this,n),this.num=e.num,this.r=e.r,this.size=e.size,this.uniforms=null,this.container}return i(n,[{key:"init",value:function(n,e){var t=this;this.container=new THREE.Group;var o=new THREE.BoxGeometry(this.size.x,this.size.y,this.size.z);(new THREE.TextureLoader).load("img/border1.png",function(i){i.wrapS=i.wrapT=THREE.RepeatWrapping,t.uniforms={time:{type:"f",value:0},texture1:{type:"t",value:i},tMatCap:{type:"t",value:THREE.ImageUtils.loadTexture("img/matcap2_.jpg")},tMatCap2:{type:"t",value:THREE.ImageUtils.loadTexture("img/nature_ice_furnace.png")},fogColor:{type:"c",value:e.color},fogFar:{type:"f",value:e.far},fogNear:{type:"f",value:e.near}};var r=new THREE.ShaderMaterial({uniforms:t.uniforms,vertexShader:s,fragmentShader:a,transparent:!0,side:THREE.DoubleSide});r.extensions.derivatives=!0,r.extensions.drawBuffers=!0;for(var c=t.num,v=0;v<c;v++){var l=new THREE.Mesh(o,r);t.container.add(l),l.position.x=t.r*Math.sin(6.28*v/c),l.position.z=t.r*Math.cos(6.28*v/c),l.rotation.y=6.28*v/c}n.add(t.container)})}},{key:"update",value:function(){this.container.rotation.y+=.001*this.r,null!=this.uniforms&&(this.uniforms.time.value+=1/60)}}]),n}();t.default=c},{glslify:13}],2:[function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),r=n("glslify"),a=r(["precision highp float;\n#define GLSLIFY 1\n\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform sampler2D texture1;\n\nvarying vec2 vUv;\nuniform float time;\n\nuniform sampler2D tMatCap;\nuniform sampler2D tMatCap2;\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nuniform float scrollPer;\n\nvarying vec2 vN2;\nvarying vec3 e;\nvarying vec3 n;\n\nvoid main() {\n\n//  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n  vec2 vUv2 = vUv + vec2(0.0,time*0.1);\n//  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n  vec4 color = texture2D( texture1, vUv2 );\n//\n  if( color.x <= 0.9 )discard;\n\n  vNormalMatrix;\n  vNormal;\n  vUv;\n\n  vec4 p = vec4( vPostion, 1. );\n  vec3 e = normalize( vec3( vModelViewMatrix * p ) );\n\n  vec3 n = normalize( vNormal );\n\n  vec3 r = reflect( e, n );\n  float m = 2. * sqrt(\n    pow( r.x, 2. ) +\n    pow( r.y, 2. ) +\n    pow( r.z + 1., 2. )\n  );\n  vec2 vN = r.xy / m + .5;\n\n  vec3 base;\n//  base = texture2D( tMatCap, vN ).rgb * texture2D( tMatCap2, vN ).rgb;// * color.xyz;\n  base = texture2D( tMatCap2, vN ).rgb;\n\n  gl_FragColor = vec4( base, 1. );\n\n//  float depth = gl_FragCoord.z / gl_FragCoord.w;\n//  float fogFactor = smoothstep( fogNear, fogFar, depth );\n//  gl_FragColor = mix( gl_FragColor, vec4( fogColor, 0.0 ), fogFactor );\n\n}"]),s=r(['#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_0(i);\n  vec4 p = permute_0( permute_0( permute_0(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x)\n{\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1(Pi0);\n  Pi1 = mod289_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1(permute_1(ix) + iy);\n  vec4 ixy0 = permute_1(ixy + iz0);\n  vec4 ixy1 = permute_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n\n#define PI 3.1415;\n\nuniform float time;\nuniform float scrollPer;\n\nvarying vec2 vUv;\n\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nvec3 sample(float t, float time) {\n  float angle = t * time * 2.0 * PI;\n  vec2 rot = vec2(cos(angle), sin(angle));\n  float z = t * 2.0 - 1.0;\n  return vec3(rot, z);\n}\n\nvec3 makeNose(vec3 pos){\n//  return  (pos);\n//  return  (pos) ;// + cnoise3(pos)*0.3;\n//  if( pos.y >= scrollPer*2.0-1.0 )return pos;\n\n//  vec3 aaa = (pos) + (cnoise3((pos)*1.0 + time*0.8 )*0.4);// - sample(sin(position.y), sin(time) )*0.3 - vec3(0.0, yy, 0.0)*0.2 ) * yy;;\n//  if( aaa.y >= scrollPer*2.0-1.0 )return pos + ( normal * snoise3(pos + time*0.2 ) * 0.1);\n\n  //float yy = (0.0-pos.y);\n\n//  return pos + ( normal * 0.1);// * snoise3(pos + time*0.4) * 0.3);\n  return pos;// + (snoise3(pos + time*0.1) * 0.3);\n//  return pos - sample(cos(position.z)*2.0,sin(time));\n//  return pos + ( normal * 2.0 * snoise3(pos * sin(time)) * 0.2) * (1.0 + sample(sin(position.z),sin(time)));\n//  return pos + (sample(position.z,sin(time) + 2.0)-1.0)*2.0;\n//  return pos + ( normal * 2.0 * snoise3(pos * (sin(time)+1.0)) * 0.2) - vec3(1.0,1.0,0.0) * sin(time*0.4)*2.0;// * (sample(position.z,sin(time) + 2.0)-1.0);\n\n//  return aaa;\n}\n\nvec3 getNeighbour(vec3 orig, float offsetT, float offsetP){\n\n//  // xyz -> Spherical coordinates\n//  float r = sqrt(orig.x*orig.x + orig.y*orig.y + orig.z*orig.z);\n//  float theta = acos(orig.z/r);\n//  float sgn = (orig.y>=0.?1.:-1.);\n//  float phi = sgn * acos(orig.x/sqrt(orig.x*orig.x + orig.y*orig.y));\n//\n//  // add offset\n//  theta += offsetT;\n//  phi += offsetP;\n//\n//  // Spherical coordinates -> xyz\n//  float x = r * sin(theta) * cos(phi);\n//  float y = r * sin(theta) * sin(phi);\n//  float z = r * cos(theta);\n\n  return vec3( orig.x + offsetT, orig.y + offsetP, orig.z );\n  \n}\n\nvoid main() {\n\n  vUv = uv;\n//  vec3 pos = position + sample(position.z, sin(time) * 2.0) + position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) * 2.0 * tan(time)) * position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n\n//  vec3 pos = position + sample(position.z, sin(time*0.4) ) * ( normal * snoise3(position*1.0 + time*0.08 ));// + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3) + sample(position.z, 1.0 )*1.0;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);\n//  vec3 pos = position;// + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n\n  float dx = 0.001;\n  vec3 pos = makeNose( position + vec3(dx) );\n\n  // calculating two other positions with a small offset, then get the cross product.\n  // ref.) https://www.opengl.org/discussion_boards/showthread.php/165885-Question-about-calculating-vertex-normals?p=1173292&viewfull=1#post1173292\n  float gridOffset\t= 0.1;\n  vec3 neighbour1\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, gridOffset, 0.        ));\n  vec3 neighbour2\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, 0.        , gridOffset));\n\n  vec3 tangent\t= neighbour1 - pos;\n  vec3 bitangent= neighbour2 - pos;\n\n  vec3 norm\t= cross(normalize(tangent), normalize(bitangent));\n\tnorm\t\t= normalize(norm);\n\tnorm\t\t= normalMatrix * norm;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n\n//  vPostion = vec4(modelViewMatrix * vec4(pos,1.0)).xyz;\n  vPostion =  pos;\n\n//  vNormal = norm;\n  vNormal = normalMatrix*normal;\n  vModelViewMatrix = modelViewMatrix;\n  vNormalMatrix = normalMatrix;\n}']),c=function(){function n(e,t){o(this,n),this.uniforms,this.container,this.r=e,this.size=t,this.rl=0}return i(n,[{key:"init",value:function(n,e){var t=this;this.container=new THREE.Group;var o=new THREE.BoxGeometry(this.size.x,this.size.y,this.size.z);(new THREE.TextureLoader).load("img/border2.png",function(i){i.wrapS=i.wrapT=THREE.RepeatWrapping,t.uniforms={time:{type:"f",value:0},texture1:{type:"t",value:i},tMatCap:{type:"t",value:THREE.ImageUtils.loadTexture("img/matcap2_.jpg")},tMatCap2:{type:"t",value:THREE.ImageUtils.loadTexture("img/matcap2_.jpg")},fogColor:{type:"c",value:e.color},fogFar:{type:"f",value:e.far},fogNear:{type:"f",value:e.near}};var r=new THREE.ShaderMaterial({uniforms:t.uniforms,vertexShader:s,fragmentShader:a,transparent:!0,side:THREE.DoubleSide});r.extensions.derivatives=!0,r.extensions.drawBuffers=!0;for(var c=0;c<6;c++){var v=new THREE.Mesh(o,r);t.container.add(v),v.position.x=t.r*Math.sin(c/6*6.28),v.position.z=t.r*Math.cos(c/6*6.28),v.rotation.y=6.28*c/6}n.add(t.container)})}},{key:"update",value:function(){null!=this.uniforms&&(this.uniforms.time.value+=1/60)}}]),n}();t.default=c},{glslify:13}],3:[function(n,e,t){"use strict"
;var o=n("glslify"),i=o(['//#pragma glslify: cnoise3 = require(glsl-noise/classic/3d)\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform float opacity;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDiffusePrev;\n\nuniform float mouseX;\nuniform float mouseY;\nuniform float time;\n\nvarying vec2 vUv;\n\nvec4 swirl(sampler2D tex, vec2 uv)\n{\n\n    float radius = 0.3;\n    float angle = 0.5;\n\n    vec2 center = vec2(mouseX, mouseY);\n    vec2 tc = (uv * 1.0) - center;\n    float dist = length(tc);\n    if( dist < radius )\n    {\n        float percent = (radius - dist) / radius;\n        float theta = percent * percent * angle * 8.0;\n        float s = sin(theta);\n        float c = cos(theta);\n        tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));\n    }\n    tc += center;\n    return texture2D(tex, tc / 1.0);\n}\n\nvoid main() {\n\n//  vec4 texel = swirl( tDiffuse, vUv );\n    vec4 prevTexel = texture2D(tDiffusePrev, vUv);\n    vec2 center = vec2(mouseX, mouseY);\n    vec2 tc = (vUv * 1.0) - center;\n    float dist = length(tc);\n\n    if( dist < 0.1 ){\n      gl_FragColor = prevTexel * 0.92 + vec4(1.0 - dist*10.0,0.0,0.0,1.0) * 0.4;\n//      gl_FragColor = vec4(1.,0.0,0.0,1.0) * 0.5;\n    }else{\n      gl_FragColor = prevTexel * 0.92 - vec4(1.0,1.0,1.0,1.0) * 0.01;\n//      gl_FragColor = vec4(0.0,0.0,0.0,1.0) * 0.5;\n    }\n\n//  vec4 texel = texture2D( tDiffuse, vUv);\n//  vec4 texel2 = texture2D( tDiffusePrev, vUv);\n//  vec4 texel = texture2D( tDiffuse, vUv + vec2(mouseX,mouseY) * cnoise2(vec2(vUv) * 2.0) );\n\n  // "vec4 texel2 = texture2D( tDiffusePrev, vUv );",\n\n//  vec2 vUv2 = vUv;\n//  float dist = distance(vec2(mouseX,mouseY), vUv2);\n//  vUv2 -= vec2(mouseX,mouseY);\n//  if (dist < 0.5){\n//     float percent = 1.0 + ((0.5 - dist) / 0.5) * 1.0;\n//     vUv2 = vUv2 * percent;\n//  }\n//  vUv2 += vec2(mouseX,mouseY);\n//  vec4 texel = texture2D( tDiffuse, vUv2);\n\n//   gl_FragColor = opacity * (texel*0.5 + texel2*0.5);\n//   gl_FragColor = opacity * (texel*0.5 + texel2*0.5);\n  // "gl_FragColor = texel + texel2*0.5;",\n  // "gl_FragColor = texel + vec4(0.0,0.0,0.0,1.0);",\n//   gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  // "gl_FragColor = 1.0 * texel2;",\n//  gl_FragColor = 1.0 * texel;\n  // "gl_FragColor = opacity * texel;",\n  // "gl_FragColor = vec4(1.0,0.0,0.0,0.5);",\n\n}']),r=o(["#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"]);THREE.DelayShader={uniforms:{tDiffuse:{value:null},tDiffusePrev:{value:null},mouseX:{value:1},mouseY:{value:1},time:{value:1},opacity:{value:1}},vertexShader:r,fragmentShader:i}},{glslify:13}],4:[function(n,e,t){"use strict";var o=n("glslify"),i=o(['//#pragma glslify: cnoise3 = require(glsl-noise/classic/3d)\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform float opacity;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDiffusePrev;\n\nuniform float mouseX;\nuniform float mouseY;\nuniform float time;\n\nvarying vec2 vUv;\n\nvec4 swirl(sampler2D tex, vec2 uv)\n{\n\n    float radius = 0.2;\n    float angle = 0.5;\n\n    vec2 center = vec2(mouseX, mouseY);\n    vec2 tc = (uv * 1.0) - center;\n    float dist = length(tc);\n    if( dist < radius )\n    {\n        float percent = (radius - dist) / radius;\n        float theta = percent * percent * angle * 8.0;\n        float s = sin(theta);\n        float c = cos(theta);\n        tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));\n    }\n    tc += center;\n    return texture2D(tex, tc / 1.0);\n}\n\nvoid main() {\n\n//    vec2 tc = (vUv * 1.0) - vec2(mouseX, mouseY);\n//    float dist = length(tc);\n\n//    if( dist < 0.3 )\n//    {\n//      gl_FragColor = vec4(1.,0.0,0.0,1.0);\n//    }else{\n//      gl_FragColor = vec4(0.,1.0,0.0,1.0);\n//    }\n//  vec4 texel = swirl( tDiffuse, vUv );\n\n//  vec4 texel2 = texture2D( tDiffuse, vUv);\n  vec4 texel2 = texture2D( tDiffusePrev, vUv);\n//  vec4 texel = texture2D( tDiffuse, vUv + vec2(mouseX,mouseY) * cnoise2(vec2(vUv) * 2.0) );\n\n  // "vec4 texel2 = texture2D( tDiffusePrev, vUv );",\n\n//  vec2 vUv2 = vUv;\n//  float dist = distance(vec2(mouseX,mouseY), vUv2);\n//  vUv2 -= vec2(mouseX,mouseY);\n//  if (dist < 0.5){\n//     float percent = 1.0 + ((0.5 - dist) / 0.5) * 1.0;\n//     vUv2 = vUv2 * percent;\n//  }\n//  vUv2 += vec2(mouseX,mouseY);\n//  vec4 texel = texture2D( tDiffuse, vUv2);\n\n//   gl_FragColor = opacity * (texel*0.5 + texel2*0.5);\n//   gl_FragColor = opacity * (texel*0.5 + texel2*0.5);\n  // "gl_FragColor = texel + texel2*0.5;",\n  // "gl_FragColor = texel + vec4(0.0,0.0,0.0,1.0);",\n//   gl_FragColor = vec4(sin(time)+1.,0.0,0.0,1.0);\n   gl_FragColor = vec4(texel2.xyz,1.0);\n//  gl_FragColor = vec4(texel2.xyz,0.1);\n  // "gl_FragColor = opacity * texel;",\n  // "gl_FragColor = vec4(1.0,0.0,0.0,0.5);",\n\n}']),r=o(["#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"]);THREE.DelayShader2={uniforms:{tDiffuse:{value:null},tDiffusePrev:{value:null},mouseX:{value:1},mouseY:{value:1},time:{value:1},opacity:{value:1}},vertexShader:r,fragmentShader:i}},{glslify:13}],5:[function(n,e,t){"use strict";var o=n("glslify"),i=o(['//#pragma glslify: cnoise3 = require(glsl-noise/classic/3d)\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform float opacity;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDiffusePrev;\nuniform sampler2D textTex;\n\nuniform float mouseX;\nuniform float mouseY;\nuniform float time;\n\nvarying vec2 vUv;\n\nvec4 swirl(sampler2D tex, vec2 uv)\n{\n\n    float radius = 0.2;\n\n    vec4 tex2 = texture2D(tex, uv);\n\n    float angle = tex2.x * 0.01;\n\n    vec2 center = vec2(mouseX, mouseY);\n    vec2 tc = (uv * 1.0) - center;\n    float dist = length(tc);\n//    if( dist < radius )\n//    {\n        float percent = (radius - dist) / radius;\n        float theta = percent * percent * angle * 8.0;\n        float s = sin(theta);\n        float c = cos(theta);\n        tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));\n//    }\n    tc += center;\n    return texture2D(tex, tc / 1.0);\n}\n\nvoid main() {\n\n//    vec2 tc = (vUv * 1.0) - vec2(mouseX, mouseY);\n//    float dist = length(tc);\n\n//    if( dist < 0.3 )\n//    {\n//      gl_FragColor = vec4(1.,0.0,0.0,1.0);\n//    }else{\n//      gl_FragColor = vec4(0.,1.0,0.0,1.0);\n//    }\n//  vec4 texel2 = swirl( tDiffuse, vUv );\n\n  vec2 vUv2 = vUv;\n  vUv2.x *= 0.09718136091;\n  vUv2.x *= 2.;\n  vec4 texel3 = texture2D( tDiffusePrev, vUv);\n  vec4 texel2 = texture2D( textTex, vUv2 + cnoise(vec2(vUv))*texel3.r * 0.1) ;\n  vec4 texel1 = texture2D( tDiffuse, vUv ) ;\n\n//  vec4 texel = texture2D( tDiffuse, vUv + vec2(mouseX,mouseY) * cnoise2(vec2(vUv) * 2.0) );\n\n  // "vec4 texel2 = texture2D( tDiffusePrev, vUv );",\n\n//  vec2 vUv2 = vUv;\n//  float dist = distance(vec2(mouseX,mouseY), vUv2);\n//  vUv2 -= vec2(mouseX,mouseY);\n//  if (dist < 0.5){\n//     float percent = 1.0 + ((0.5 - dist) / 0.5) * 1.0;\n//     vUv2 = vUv2 * percent;\n//  }\n//  vUv2 += vec2(mouseX,mouseY);\n//  vec4 texel = texture2D( tDiffuse, vUv2);\n\n//   gl_FragColor = opacity * (texel*0.5 + texel2*0.5);\n//   gl_FragColor = (texel2*0.5 + texel3*0.5);\n  // "gl_FragColor = texel + texel2*0.5;",\n  // "gl_FragColor = texel + vec4(0.0,0.0,0.0,1.0);",\n//   gl_FragColor = vec4(sin(time)+1.,0.0,0.0,1.0);\n//   gl_FragColor = vec4(texel2.x, 0.0,0.0,1.0);\n//  gl_FragColor = vec4(texel2.xyz,0.1);\n//  gl_FragColor = texel2;\n  gl_FragColor = texel2;\n  // "gl_FragColor = vec4(1.0,0.0,0.0,0.5);",\n\n}']),r=o(["#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"]);THREE.DelayShader3={uniforms:{tDiffuse:{value:null},tDiffusePrev:{value:null},textTex:{value:null},mouseX:{value:1},mouseY:{value:1},time:{value:1},opacity:{value:1}},vertexShader:r,fragmentShader:i}},{glslify:13}],6:[function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),r=n("glslify"),a=r(["precision highp float;\n#define GLSLIFY 1\n\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform sampler2D texture1;\n\nvarying vec2 vUv;\nuniform float time;\n\nuniform sampler2D tMatCap;\nuniform sampler2D tMatCap2;\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nuniform float scrollPer;\n\nvarying vec2 vN2;\nvarying vec3 e;\nvarying vec3 n;\n\nvoid main() {\n\n//  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n//  vec2 vUv2 = vUv + vec2(0.0,time*0.1);\n  vec2 vUv2 = vUv + vec2(time*0.0,time*0.3);\n//  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n  vec4 color = texture2D( texture1, vUv2 );\n//\n  if( color.x <= 0.9 )discard;\n\n  vNormalMatrix;\n  vNormal;\n  vUv;\n\n  vec4 p = vec4( vPostion, 1. );\n  vec3 e = normalize( vec3( vModelViewMatrix * p ) );\n\n  vec3 n = normalize( vNormal );\n\n  vec3 r = reflect( e, n );\n  float m = 2. * sqrt(\n    pow( r.x, 2. ) +\n    pow( r.y, 2. ) +\n    pow( r.z + 1., 2. )\n  );\n  vec2 vN = r.xy / m + .5;\n//  vN.x += 100.0;\n  vec3 base;\n  base = texture2D( tMatCap, vN ).rgb;\n\n  gl_FragColor = vec4( base, 1. )+ color;\n\n//  float depth = gl_FragCoord.z / gl_FragCoord.w;\n//  float fogFactor = smoothstep( fogNear, fogFar, depth );\n//  gl_FragColor = mix( gl_FragColor, vec4( fogColor, 0.0 ), fogFactor );\n\n}"]),s=r(['#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_0(i);\n  vec4 p = permute_0( permute_0( permute_0(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x)\n{\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1(Pi0);\n  Pi1 = mod289_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1(permute_1(ix) + iy);\n  vec4 ixy0 = permute_1(ixy + iz0);\n  vec4 ixy1 = permute_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n\n#define PI 3.1415;\n\nuniform float time;\nuniform float scrollPer;\n\nvarying vec2 vUv;\n\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nvec3 sample(float t, float time) {\n  float angle = t * time * 2.0 * PI;\n  vec2 rot = vec2(cos(angle), sin(angle));\n  float z = 2. * t * 2.0 - 1.0;\n  return vec3(rot, z);\n}\n\nvec3 makeNose(vec3 pos){\n//  return  (pos);\n//  return  (pos) + sample(position.z+tan(time),1.0) + cnoise3(pos)*0.7;\n  return  (pos) + sample(position.z+tan(time),1.0) + cnoise(pos)*0.7;\n//  float pos1 = cnoise3(pos);\n//  return  (pos) + sample(position.y,1.0);// + cnoise3(pos)*0.1;\n//  if( pos.y >= scrollPer*2.0-1.0 )return pos;\n\n//  vec3 aaa = (pos) + (cnoise3((pos)*1.0 + time*0.8 )*0.4);// - sample(sin(position.y), sin(time) )*0.3 - vec3(0.0, yy, 0.0)*0.2 ) * yy;;\n//  if( aaa.y >= scrollPer*2.0-1.0 )return pos + ( normal * snoise3(pos + time*0.2 ) * 0.1);\n\n  //float yy = (0.0-pos.y);\n\n//  return pos + ( normal * 1.0 * snoise3(pos + time*0.4) * 0.3);\n//  return pos + ( normal * 2.0 * snoise3(pos * sin(time)) * 0.2) * (1.0 + sample(sin(position.z),sin(time)));\n//  return pos + (sample(position.z,sin(time) + 2.0)-1.0)*2.0;\n//  return pos + ( normal * 2.0 * snoise3(pos * (sin(time)+1.0)) * 0.2);// * (sample(position.z,sin(time) + 2.0)-1.0);\n\n//  return aaa;\n}\n\nvec3 getNeighbour(vec3 orig, float offsetT, float offsetP){\n\n  // xyz -> Spherical coordinates\n  float r = sqrt(orig.x*orig.x + orig.y*orig.y + orig.z*orig.z);\n  float theta = acos(orig.z/r);\n  float sgn = (orig.y>=0.?1.:-1.);\n  float phi = sgn * acos(orig.x/sqrt(orig.x*orig.x + orig.y*orig.y));\n\n  // add offset\n  theta += offsetT;\n  phi += offsetP;\n\n  // Spherical coordinates -> xyz\n  float x = r * sin(theta) * cos(phi);\n  float y = r * sin(theta) * sin(phi);\n  float z = r * cos(theta);\n\n  return vec3( x, y, z );\n  \n}\n\nvoid main() {\n\n  vUv = uv;\n//  vec3 pos = position + sample(position.z, sin(time) * 2.0) + position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) * 2.0 * tan(time)) * position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n\n//  vec3 pos = position + sample(position.z, sin(time*0.4) ) * ( normal * snoise3(position*1.0 + time*0.08 ));// + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3) + sample(position.z, 1.0 )*1.0;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);\n//  vec3 pos = position;// + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n\n  float dx = 0.001;\n  vec3 pos = makeNose( position + vec3(dx) );\n\n  // calculating two other positions with a small offset, then get the cross product.\n  // ref.) https://www.opengl.org/discussion_boards/showthread.php/165885-Question-about-calculating-vertex-normals?p=1173292&viewfull=1#post1173292\n  float gridOffset\t= 0.1;\n  vec3 neighbour1\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, gridOffset, 0.        ));\n  vec3 neighbour2\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, 0.        , gridOffset));\n\n  vec3 tangent\t= neighbour1 - pos;\n  vec3 bitangent= neighbour2 - pos;\n\n  vec3 norm\t= cross(normalize(tangent), normalize(bitangent));\n\tnorm\t\t= normalize(norm);\n\tnorm\t\t= normalMatrix * norm;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n\n//  vPostion = vec4(modelViewMatrix * vec4(pos,1.0)).xyz;\n  vPostion =  pos;\n\n  vNormal = norm;\n  vModelViewMatrix = modelViewMatrix;\n  vNormalMatrix = normalMatrix;\n\n}']),c=function(){function n(e){o(this,n),this.uniforms=null,this.container,this.isReturn=e}return i(n,[{key:"init",value:function(n,e){var t=this;this.container=new THREE.Group;var o=new THREE.IcosahedronGeometry(.7,5);(new THREE.TextureLoader).load("img/matcap2_++.jpg",function(i){i.wrapS=i.wrapT=THREE.RepeatWrapping,t.uniforms={time:{type:"f",value:0},texture1:{type:"t",value:i},tMatCap:{type:"t",value:THREE.ImageUtils.loadTexture("img/matcap2_+_.png")},tMatCap2:{type:"t",value:THREE.ImageUtils.loadTexture("img/nature_ice_furnace.png")},fogColor:{type:"c",value:e.color},fogFar:{type:"f",value:e.far},fogNear:{type:"f",value:e.near}};var r=new THREE.ShaderMaterial({uniforms:t.uniforms,vertexShader:s,fragmentShader:a,transparent:!0,side:THREE.DoubleSide,wireframe:!1});new THREE.MeshBasicMaterial({color:16711680}),r.extensions.derivatives=!0,r.extensions.drawBuffers=!0;var c=new THREE.Mesh(o,r);t.container.add(c),n.add(t.container)})}},{key:"update",value:function(){null!=this.uniforms&&(this.uniforms.time.value+=.01,this.container.rotation.z+=.01,this.container.rotation.x=1.57)}}]),n}();t.default=c},{glslify:13}],7:[function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}
}(),r=n("glslify"),a=r(["precision highp float;\n#define GLSLIFY 1\n\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform sampler2D texture1;\n\nvarying vec2 vUv;\nuniform float time;\n\nuniform sampler2D tMatCap;\nuniform sampler2D tMatCap2;\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nuniform float scrollPer;\n\nvarying vec2 vN2;\nvarying vec3 e;\nvarying vec3 n;\n\nvoid main() {\n\n//  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n//  vec2 vUv2 = vUv + vec2(0.0,time*0.1);\n  vec2 vUv2 = vUv + vec2(time*0.3,time*0.8);\n//  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n  vec4 color = texture2D( texture1, vUv2 );\n//\n//  if( color.x <= 0.9 )discard;\n\n  vNormalMatrix;\n  vNormal;\n  vUv;\n\n  vec4 p = vec4( vPostion, 1. );\n  vec3 e = normalize( vec3( vModelViewMatrix * p ) );\n\n  vec3 n = normalize( vNormal );\n\n  vec3 r = reflect( e, n );\n  float m = 2. * sqrt(\n    pow( r.x, 2. ) +\n    pow( r.y, 2. ) +\n    pow( r.z + 1., 2. )\n  );\n  vec2 vN = r.xy / m + .5;\n//  vN.x += 1.0;\n  vec3 base;\n  base = texture2D( tMatCap, vN ).rgb;\n\n  gl_FragColor = vec4( base, 1. );// * color;\n\n//  float depth = gl_FragCoord.z / gl_FragCoord.w;\n//  float fogFactor = smoothstep( fogNear, fogFar, depth );\n//  gl_FragColor = mix( gl_FragColor, vec4( fogColor, 0.0 ), fogFactor );\n\n}"]),s=r(['#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_0(i);\n  vec4 p = permute_0( permute_0( permute_0(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x)\n{\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1(Pi0);\n  Pi1 = mod289_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1(permute_1(ix) + iy);\n  vec4 ixy0 = permute_1(ixy + iz0);\n  vec4 ixy1 = permute_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n\n#define PI 3.1415;\n\nuniform float time;\nuniform float scrollPer;\n\nvarying vec2 vUv;\n\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nvec3 sample(float t, float time) {\n  float angle = t * time * 2.0 * PI;\n  vec2 rot = vec2(cos(angle), sin(angle));\n  float z = 2. * t * 2.0 - 1.0;\n  return vec3(rot, z);\n}\n\nvec3 makeNose(vec3 pos){\n//  return  (pos);\n  return  (pos) + sample(position.z+tan(time),1.0) + cnoise(pos)*0.7;\n//  float pos1 = cnoise3(pos);\n//  return  (pos) + sample(position.z,1.0) + cnoise3(pos)*0.5;\n//  if( pos.y >= scrollPer*2.0-1.0 )return pos;\n\n//  vec3 aaa = (pos) + (cnoise3((pos)*1.0 + time*0.8 )*0.4);// - sample(sin(position.y), sin(time) )*0.3 - vec3(0.0, yy, 0.0)*0.2 ) * yy;;\n//  if( aaa.y >= scrollPer*2.0-1.0 )return pos + ( normal * snoise3(pos + time*0.2 ) * 0.1);\n\n  //float yy = (0.0-pos.y);\n\n//  return pos + ( normal * 1.0 * snoise3(pos + time*0.4) * 0.3);\n//  return pos + ( normal * 2.0 * snoise3(pos * sin(time)) * 0.2) * (1.0 + sample(sin(position.z),sin(time)));\n//  return pos + (sample(position.z,sin(time) + 2.0)-1.0)*2.0;\n//  return pos + ( normal * 2.0 * snoise3(pos * (sin(time)+1.0)) * 0.2);// * (sample(position.z,sin(time) + 2.0)-1.0);\n\n//  return aaa;\n}\n\nvec3 getNeighbour(vec3 orig, float offsetT, float offsetP){\n\n  // xyz -> Spherical coordinates\n  float r = sqrt(orig.x*orig.x + orig.y*orig.y + orig.z*orig.z);\n  float theta = acos(orig.z/r);\n  float sgn = (orig.y>=0.?1.:-1.);\n  float phi = sgn * acos(orig.x/sqrt(orig.x*orig.x + orig.y*orig.y));\n\n  // add offset\n  theta += offsetT;\n  phi += offsetP;\n\n  // Spherical coordinates -> xyz\n  float x = r * sin(theta) * cos(phi);\n  float y = r * sin(theta) * sin(phi);\n  float z = r * cos(theta);\n\n  return vec3( x, y, z );\n  \n}\n\nvoid main() {\n\n  vUv = uv;\n//  vec3 pos = position + sample(position.z, sin(time) * 2.0) + position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) * 2.0 * tan(time)) * position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n\n//  vec3 pos = position + sample(position.z, sin(time*0.4) ) * ( normal * snoise3(position*1.0 + time*0.08 ));// + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3) + sample(position.z, 1.0 )*1.0;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);\n//  vec3 pos = position;// + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n\n  float dx = 0.001;\n  vec3 pos = makeNose( position + vec3(dx) );\n\n  // calculating two other positions with a small offset, then get the cross product.\n  // ref.) https://www.opengl.org/discussion_boards/showthread.php/165885-Question-about-calculating-vertex-normals?p=1173292&viewfull=1#post1173292\n  float gridOffset\t= 0.1;\n  vec3 neighbour1\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, gridOffset, 0.        ));\n  vec3 neighbour2\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, 0.        , gridOffset));\n\n  vec3 tangent\t= neighbour1 - pos;\n  vec3 bitangent= neighbour2 - pos;\n\n  vec3 norm\t= cross(normalize(tangent), normalize(bitangent));\n\tnorm\t\t= normalize(norm);\n\tnorm\t\t= normalMatrix * norm;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n\n//  vPostion = vec4(modelViewMatrix * vec4(pos,1.0)).xyz;\n  vPostion =  pos;\n\n  vNormal = norm;\n  vModelViewMatrix = modelViewMatrix;\n  vNormalMatrix = normalMatrix;\n\n}']),c=function(){function n(e){o(this,n),this.uniforms=null,this.container,this.isReturn=e}return i(n,[{key:"init",value:function(n,e){var t=this;this.container=new THREE.Group;var o=new THREE.IcosahedronGeometry(.7,5);(new THREE.TextureLoader).load("img/border1.png",function(i){i.wrapS=i.wrapT=THREE.RepeatWrapping,t.uniforms={time:{type:"f",value:0},texture1:{type:"t",value:i},tMatCap:{type:"t",value:THREE.ImageUtils.loadTexture("img/matcap2_.jpg")},tMatCap2:{type:"t",value:THREE.ImageUtils.loadTexture("img/nature_ice_furnace.png")},fogColor:{type:"c",value:e.color},fogFar:{type:"f",value:e.far},fogNear:{type:"f",value:e.near}};var r=new THREE.ShaderMaterial({uniforms:t.uniforms,vertexShader:s,fragmentShader:a,transparent:!0,side:THREE.DoubleSide,wireframe:!1});new THREE.MeshBasicMaterial({color:16711680}),r.extensions.derivatives=!0,r.extensions.drawBuffers=!0;var c=new THREE.Mesh(o,r);t.container.add(c),n.add(t.container),t.container.rotation.x=1.57,t.container.scale.x=.5,t.container.scale.y=.5})}},{key:"update",value:function(){null!=this.uniforms&&(this.uniforms.time.value+=.01,this.container.rotation.z+=.01)}}]),n}();t.default=c},{glslify:13}],8:[function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),r=n("glslify"),a=r(["precision highp float;\n#define GLSLIFY 1\n\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform float time;\n\nuniform sampler2D tMatCap;\nvarying vec3 vNormal;\nvarying vec3 vPostion;\n\nvoid main() {\n\n  vec3 e = normalize( vPostion );\n  vec3 n = normalize( vNormal );\n\n  vec3 r = reflect( e, n );\n  float m = 2. * sqrt(\n    pow( r.x, 2. ) +\n    pow( r.y, 2. ) +\n    pow( r.z + 1., 2. )\n  );\n  vec2 vN = r.xy / m + .5;\n\n  vec3 base;\n  base = texture2D( tMatCap, vN ).rgb;\n\n  gl_FragColor = vec4( base, 1.0 );\n\n}"]),s=r(['#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_0(i);\n  vec4 p = permute_0( permute_0( permute_0(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x)\n{\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1(Pi0);\n  Pi1 = mod289_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1(permute_1(ix) + iy);\n  vec4 ixy0 = permute_1(ixy + iz0);\n  vec4 ixy1 = permute_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n\n#define PI 3.1415;\n\nuniform float time;\n\nvarying vec3 vNormal;\nvarying vec3 vPostion;\n\nvoid main() {\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n\n  vPostion = vec4(modelViewMatrix * vec4(position,1.0)).xyz;\n//  vPostion = vec3(modelViewMatrix * pos).xyz;\n\n  vNormal = normalMatrix * normal;\n\n}']),c=function(){function n(){o(this,n),this.uniforms=null,this.container}return i(n,[{key:"init",value:function(n){var e=this;this.container=new THREE.Group;var t=new THREE.IcosahedronGeometry(10,1);(new THREE.TextureLoader).load("img/border1.png",function(o){o.wrapS=o.wrapT=THREE.RepeatWrapping,e.uniforms={time:{type:"f",value:0},texture1:{type:"t",value:o},tMatCap:{type:"t",value:THREE.ImageUtils.loadTexture("img/matcap2_+_.png")},tMatCap2:{type:"t",value:THREE.ImageUtils.loadTexture("img/nature_ice_furnace.png")}};var i=new THREE.ShaderMaterial({uniforms:e.uniforms,vertexShader:s,fragmentShader:a,side:THREE.BackSide});new THREE.MeshBasicMaterial({color:16711680}),i.extensions.derivatives=!0,i.extensions.drawBuffers=!0;var r=new THREE.Mesh(t,i);e.container.add(r),n.add(e.container)})}},{key:"update",value:function(){null!=this.uniforms&&(this.uniforms.time.value+=.01)}}]),n}();t.default=c},{glslify:13}],9:[function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),r=(n("glslify"),function(){function n(){o(this,n),this.container}return i(n,[{key:"init",value:function(n){for(var e=new THREE.LineBasicMaterial({color:16579836,fog:!0}),t=0;t<10;t++){for(var o=[],i=0;i<5;i++)o.push(new THREE.Vector3(Math.random()-.5+.2*Math.sin(t/10*6.28),i/4*8-4,Math.random()-.5+.2*Math.cos(t/10*6.28)));var r=new THREE.CatmullRomCurve3(o),a=new THREE.Geometry;a.vertices=r.getPoints(50);var s=new THREE.Line(a,e);n.add(s)}}},{key:"update",value:function(){null!=this.uniforms&&(this.uniforms.time.value+=1/60)}}]),n}());t.default=r},{glslify:13}],10:[function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}
}(),r=n("glslify"),a=r(["precision highp float;\n#define GLSLIFY 1\n\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform sampler2D texture1;\n\nvarying vec2 vUv;\nuniform float time;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nuniform sampler2D tMatCap;\nuniform sampler2D tMatCap2;\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nuniform float scrollPer;\n\nvarying vec2 vN2;\nvarying vec3 e;\nvarying vec3 n;\n\nvoid main() {\n\n//  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n  vec2 vUv2 = vUv + vec2(time*0.1,0.0);\n//  vec2 vUv2 = vUv + vec2(time*0.3,time*0.3);\n  vec4 color = texture2D( texture1, vUv2 );\n//\n  if( color.x <= 0.8 )discard;\n\n  vNormalMatrix;\n  vNormal;\n  vUv;\n\n  vec4 p = vec4( vPostion, 1. );\n  vec3 e = normalize( vec3( vModelViewMatrix * p ) );\n\n  vec3 n = normalize( vNormal );\n\n  vec3 r = reflect( e, n );\n  float m = 2. * sqrt(\n    pow( r.x, 2. ) +\n    pow( r.y, 2. ) +\n    pow( r.z + 1., 2. )\n  );\n  vec2 vN = r.xy / m + .5;\n\n  vec3 base;\n  base = texture2D( tMatCap, vN ).rgb + color.xyz;\n\n  gl_FragColor = vec4( base, .8 );\n\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  float fogFactor = smoothstep( fogNear, fogFar, depth );\n  gl_FragColor = mix( gl_FragColor, vec4( fogColor, 0.0 ), fogFactor );\n\n}"]),s=r(['#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_0(i);\n  vec4 p = permute_0( permute_0( permute_0(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x)\n{\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1(Pi0);\n  Pi1 = mod289_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1(permute_1(ix) + iy);\n  vec4 ixy0 = permute_1(ixy + iz0);\n  vec4 ixy1 = permute_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n\n#define PI 3.1415;\n\nuniform float time;\nuniform float scrollPer;\n\nvarying vec2 vUv;\n\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\n\nvec3 sample(float t, float time) {\n  float angle = t * time * 2.0 * PI;\n  vec2 rot = vec2(cos(angle), sin(angle));\n  float z = t * 2.0 - 1.0;\n  return vec3(rot, z);\n}\n\nvec3 makeNose(vec3 pos){\n//  return  (pos);\n  return  (pos);// + cnoise3(pos)*0.3;\n//  if( pos.y >= scrollPer*2.0-1.0 )return pos;\n\n//  vec3 aaa = (pos) + (cnoise3((pos)*1.0 + time*0.8 )*0.4);// - sample(sin(position.y), sin(time) )*0.3 - vec3(0.0, yy, 0.0)*0.2 ) * yy;;\n//  if( aaa.y >= scrollPer*2.0-1.0 )return pos + ( normal * snoise3(pos + time*0.2 ) * 0.1);\n\n  //float yy = (0.0-pos.y);\n\n//  return pos + ( normal * 4.0 * snoise3(pos + time*0.4) * 0.3);\n//  return pos + ( normal * 2.0 * snoise3(pos * sin(time)) * 0.2) * (1.0 + sample(sin(position.z),sin(time)));\n//  return pos + (sample(position.z,sin(time) + 2.0)-1.0)*2.0;\n//  return pos + ( normal * 2.0 * snoise3(pos * (sin(time)+1.0)) * 0.2);// * (sample(position.z,sin(time) + 2.0)-1.0);\n\n//  return aaa;\n}\n\nvec3 getNeighbour(vec3 orig, float offsetT, float offsetP){\n\n  // xyz -> Spherical coordinates\n  float r = sqrt(orig.x*orig.x + orig.y*orig.y + orig.z*orig.z);\n  float theta = acos(orig.z/r);\n  float sgn = (orig.y>=0.?1.:-1.);\n  float phi = sgn * acos(orig.x/sqrt(orig.x*orig.x + orig.y*orig.y));\n\n  // add offset\n  theta += offsetT;\n  phi += offsetP;\n\n  // Spherical coordinates -> xyz\n  float x = r * sin(theta) * cos(phi);\n  float y = r * sin(theta) * sin(phi);\n  float z = r * cos(theta);\n\n  return vec3( x, y, z );\n  \n}\n\nvoid main() {\n\n  vUv = uv;\n//  vec3 pos = position + sample(position.z, sin(time) * 2.0) + position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) * 2.0 * tan(time)) * position * snoise3(position * 0.5 + sin(time));\n//  vec3 pos = position + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n\n//  vec3 pos = position + sample(position.z, sin(time*0.4) ) * ( normal * snoise3(position*1.0 + time*0.08 ));// + sample(position.x, sin(time) ) * position * snoise3(position * 0.5 + sin(time)*0.1);\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3) + sample(position.z, 1.0 )*1.0;\n//  vec3 pos = position + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);\n//  vec3 pos = position;// + ( normal * snoise3(position * vec3(1.01,1.01,1.01) + time*0.8 ) * 0.3);// + sample(position.z*position.x*position.y, sin(time) )*0.4;\n\n  float dx = 0.001;\n  vec3 pos = makeNose( position + vec3(dx) );\n\n  // calculating two other positions with a small offset, then get the cross product.\n  // ref.) https://www.opengl.org/discussion_boards/showthread.php/165885-Question-about-calculating-vertex-normals?p=1173292&viewfull=1#post1173292\n  float gridOffset\t= 0.1;\n  vec3 neighbour1\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, gridOffset, 0.        ));\n  vec3 neighbour2\t= makeNose(getNeighbour(position+vec3(dx)/*for specfic point(0,0,0)*/, 0.        , gridOffset));\n\n  vec3 tangent\t= neighbour1 - pos;\n  vec3 bitangent= neighbour2 - pos;\n\n  vec3 norm\t= cross(normalize(tangent), normalize(bitangent));\n\tnorm\t\t= normalize(norm);\n\tnorm\t\t= normalMatrix * norm;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n\n//  vPostion = vec4(modelViewMatrix * vec4(pos,1.0)).xyz;\n  vPostion =  pos;\n\n//  vNormal = norm;\n  vNormal = normalMatrix * normal;\n  vModelViewMatrix = modelViewMatrix;\n  vNormalMatrix = normalMatrix;\n\n}']),c=function(){function n(){o(this,n),this.container}return i(n,[{key:"init",value:function(n,e){var t=this;this.container=new THREE.Group,(new THREE.TextureLoader).load("img/border4.png",function(o){o.wrapS=o.wrapT=THREE.RepeatWrapping,t.uniforms={time:{type:"f",value:0},texture1:{type:"t",value:o},tMatCap:{type:"t",value:THREE.ImageUtils.loadTexture("img/matcap2_+.png")},tMatCap2:{type:"t",value:THREE.ImageUtils.loadTexture("img/matcap2_.jpg")},fogColor:{type:"c",value:e.color},fogFar:{type:"f",value:e.far},fogNear:{type:"f",value:e.near}};var i=new THREE.ShaderMaterial({uniforms:t.uniforms,vertexShader:s,fragmentShader:a,transparent:!0,side:THREE.DoubleSide});i.extensions.derivatives=!0,i.extensions.drawBuffers=!0;for(var r=0;r<2;r++){for(var c=[],v=0;v<5;v++)c.push(new THREE.Vector3(Math.random()-.5+.8*Math.sin(r/2*6.28),v/4*12-6,Math.random()-.5+.8*Math.cos(r/2*6.28)));var l=new THREE.CatmullRomCurve3(c),x=new THREE.TubeGeometry(l,20,.02,3,!1),m=new THREE.Mesh(x,i);t.container.add(m)}n.add(t.container)})}},{key:"update",value:function(){null!=this.uniforms&&(this.uniforms.time.value+=1/60)}}]),n}();t.default=c},{glslify:13}],11:[function(n,e,t){"use strict";function o(){function n(){e=window.innerWidth,t=window.innerHeight,r&&(r.setSize(e,t),r.setViewport(0,0,e,t),s.aspect=e/t,s.updateProjectionMatrix())}var e,t;e=window.innerWidth,t=window.innerHeight;var o=Math.min(1.5,window.devicePixelRatio),r=new THREE.WebGLRenderer({canvas:document.getElementById("canvas"),antialias:!0});r.setClearColor(2236962,1),r.setSize(e,t),r.setPixelRatio(o);var a=new THREE.Scene,s=new THREE.PerspectiveCamera(95,e/t,.01,1e3);s.position.set(0,0,2.5),s.lookAt(new THREE.Vector3);var c=new i(s);return window.addEventListener("resize",n),{renderer:r,scene:a,controls:c,camera:s}}var i=n("three-orbit-controls")(THREE);e.exports=o},{"three-orbit-controls":14}],12:[function(n,e,t){"use strict";function o(n){return n&&n.__esModule?n:{default:n}}function i(){I&&clearTimeout(I),I=setTimeout(function(){var n=$(window).width(),e=$(window).height(),t=Math.min(1.5,window.devicePixelRatio);T.setSize(n*t,e*t),S.setSize(n*t,e*t),R.setSize(n*t,e*t)},200)}function r(){H+=.01,H>6.28&&(H-=6.28),w.forEach(function(n){return n.update()}),L.uniforms.mouseX.value=j,L.uniforms.mouseY.value=A,L.uniforms.time.value+=1/60,N.uniforms.mouseX.value=j,N.uniforms.mouseY.value=A,N.uniforms.time.value+=1/60,U.uniforms.mouseX.value=j,U.uniforms.mouseY.value=A,U.uniforms.time.value+=1/60,L.uniforms.tDiffusePrev.value=D,N.uniforms.tDiffusePrev.value=M,U.uniforms.tDiffusePrev.value=M,U.uniforms.textTex.value=E,T.render(),S.render(),R.render(),requestAnimationFrame(r)}var a=n("./js/LiquidSphere"),s=(o(a),n("./js/LiquidSphere2")),c=(o(s),n("./js/CircleBoxes")),v=(o(c),n("./js/CirclePanels")),l=(o(v),n("./js/ThinLines")),x=(o(l),n("./js/TubeLines")),m=(o(x),n("./js/SkySphere")),f=(o(m),n("./js/DelayPass")),g=o(f),p=n("./js/DelayPass2"),u=(o(p),n("./js/DelayPass3")),y=(o(u),n("./lib/createThree")),d=y(),h=d.camera,z=d.scene,C=d.renderer,w=(d.controls,[]);console.log(g.default);var P=new THREE.Group;z.add(P);var b={color:new THREE.Color(11585751),near:.1,far:8};z.fog=new THREE.Fog(b.color,b.near,b.far);var _=new Image;_.src="data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3Csvg%20width%3D%2221074px%22%20height%3D%222048px%22%20viewBox%3D%220%200%2021074%202048%22%20version%3D%221.1%22%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%3E%0A%20%20%20%20%3Cg%20id%3D%22Page-1%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%0A%20%20%20%20%20%20%20%20%3Cg%20id%3D%22Artboard%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Crect%20id%3D%22Rectangle%22%20fill%3D%22%23444444%22%20x%3D%220%22%20y%3D%220%22%20width%3D%2221074%22%20height%3D%222048%22%3E%3C/rect%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M749.097865%2C1332.09704%20L247%2C1434.48903%20L252.897956%2C1473.10379%20C300.94492%2C1787.64713%20599.434112%2C2024%20959.033175%2C2024%20C1350.50478%2C2024%201670.23756%2C1754.72909%201670.23756%2C1416.98926%20C1670.23756%2C1134.2601%201432.04375%2C943.867942%201151.70806%2C873.228223%20C985.654354%2C831.098267%20784.823782%2C789.27196%20784.823782%2C659.564566%20C784.823782%2C576.890778%20865.455374%2C509.149429%20960.353755%2C509.149429%20C1084.46089%2C509.149429%201133.89988%2C596.63994%201133.89988%2C717.435503%20L1638.79133%2C615.862774%20L1633.47566%2C577.639782%20C1590.14659%2C266.054341%201317.08065%2C26.1946159%20957.707832%2C26.1946159%20C563.580781%2C26.1946159%20274.482116%2C297.267185%20274.482116%2C632.601632%20C274.482116%2C908.785049%20503.786728%2C1106.3493%20776.828854%2C1187.06663%20C950.985853%2C1238.61807%201163.67307%2C1258.70184%201163.67307%2C1388.84983%20C1163.67307%2C1464.60039%201056.22144%2C1539.25663%20955.723985%2C1539.25663%20L930.316216%2C1539.25663%20L929.935165%2C1539.20662%20C835.869142%2C1526.96773%20749.097865%2C1455.92553%20749.097865%2C1383.37817%20L749.097865%2C1332.09704%20Z%20M3029.20966%2C1538.44928%20C2919.13473%2C1538.44928%202827.61223%2C1506.5172%202748.83111%2C1440.67753%20C2669.71658%2C1373.16481%202631.69721%2C1296.17345%202631.69721%2C1205.04271%20L2631.69721%2C39.8517235%20L2148.82933%2C39.8517235%20L2148.82933%2C1221.77681%20C2148.82933%2C1442.36964%202231.44834%2C1633.58462%202394.26788%2C1789.68695%20C2557.13743%2C1945.02241%202772.03236%2C2023.75589%203030.57549%2C2023.75589%20C3286.55725%2C2023.75589%203500.47335%2C1944.97954%203664.11215%2C1789.72505%20C3827.00909%2C1633.54771%203909.59%2C1442.38393%203909.59%2C1221.77681%20L3909.59%2C39.8517235%20L3426.72211%2C39.8517235%20L3426.72211%2C1205.04271%20C3426.72211%2C1396.91144%203228.34575%2C1538.44928%203029.20966%2C1538.44928%20Z%20M5011.91328%2C596.491091%20C5011.91328%2C648.885554%205077.51203%2C680.017481%205132.4665%2C680.017481%20L5148.21159%2C680.017481%20C5192.99793%2C675.076116%205248.95613%2C646.420854%205248.95613%2C596.491091%20C5248.95613%2C544.93228%205182.1811%2C512.964702%205131.11196%2C512.964702%20C5076.35636%2C512.964702%205011.91326%2C545.286818%205011.91328%2C596.491091%20Z%20M5757.52682%2C596.032639%20C5757.52682%2C705.707466%205725.72335%2C808.095882%205664.96952%2C897.935811%20C5791.95002%2C1024.22565%205855.07589%2C1176.84017%205855.07589%2C1353.39422%20C5855.07589%2C1533.3813%205787.47029%2C1689.93017%205654.79427%2C1817.10119%20C5519.22468%2C1943.58513%205337.74932%2C2007.90417%205128.40291%2C2007.90417%20C4919.09883%2C2007.90417%204737.47665%2C1943.49463%204601.97523%2C1817.19526%20C4468.53473%2C1690.94233%204400.37541%2C1534.14816%204400.37541%2C1353.39422%20C4400.37541%2C1176.7711%204465.60897%2C1022.83839%204592.42752%2C897.208241%20C4530.54126%2C805.265387%204500.36321%2C705.353803%204500.36321%2C596.032639%20C4500.36321%2C442.466686%204558.76643%2C308.390303%204672.65782%2C200.058682%20C4795.25584%2C91.6544224%204951.06125%2C36.1924427%205129.75744%2C36.1924427%20C5306.87027%2C36.1924427%205462.19815%2C91.5436795%205586.39441%2C200.002715%20C5699.78806%2C308.691572%205757.52682%2C442.491693%205757.52682%2C596.032639%20Z%20M5127.04973%2C1532.35127%20C5246.05099%2C1532.35127%205357.31994%2C1443.48457%205357.31994%2C1326.27886%20C5357.31994%2C1270.73353%205335.34717%2C1223.47963%205288.31031%2C1179.40512%20C5244.71928%2C1140.48076%205200.21423%2C1122.37845%205147.31742%2C1118.42743%20L5143.98797%2C1121.42582%20L5124.34198%2C1121.42582%20C5004.10043%2C1121.42582%204898.13406%2C1213.12218%204898.13406%2C1328.71759%20C4898.13406%2C1444.36357%205003.92804%2C1532.35127%205127.04971%2C1532.35127%20L5127.04973%2C1532.35127%20Z%20M6345.86126%2C2007.90417%20L7701.79331%2C2007.90417%20L7701.79331%2C1529.91373%20L6849.27614%2C1529.91373%20L6849.27614%2C1261.6538%20L7504.25644%2C1261.6538%20L7504.25644%2C782.444002%20L6849.27614%2C782.444002%20L6849.27614%2C514.184066%20L7701.79331%2C514.184066%20L7701.79331%2C34.9742701%20L6345.86126%2C34.9742701%20L6345.86126%2C2007.90417%20Z%20M8661.94904%2C2005.46544%20L8181.54608%2C2005.46544%20L8180.27552%2C39.8517235%20L8899.00804%2C39.8517235%20C9016.18362%2C39.8517235%209130.52394%2C56.5167528%209241.09186%2C89.6789109%20C9337.29296%2C123.217357%209421.69219%2C174.566367%209494.37887%2C243.398475%20C9618.48005%2C362.335224%209697.18853%2C479.364335%209697.18853%2C700.120305%20L9697.18853%2C749.202061%20C9697.18853%2C885.009845%209652.37692%2C1013.33593%209564.9138%2C1131.6749%20C9502.34879%2C1215.62045%209449.97451%2C1258.69113%209357.88043%2C1300.54363%20L9830.18368%2C2005.46544%20L9246.01932%2C2005.46544%20L8661.94904%2C1237.46658%20L8661.94904%2C2005.46544%20Z%20M8943.27784%2C975.103411%20C9074.80118%2C975.103411%209197.47223%2C876.362368%209197.47223%2C740.986839%20C9197.47223%2C680.41163%209172.25499%2C628.593451%209120.57017%2C582.049257%20C9069.41169%2C540.035997%208960.18817%2C516.622792%208870.44708%2C516.622792%20L8660.73087%2C516.622792%20L8660.73087%2C973.884047%20L8839.02942%2C973.884047%20L8839.02942%2C975.103411%20L8943.27784%2C975.103411%20Z%20M10260.0009%2C2005.46544%20L11615.9329%2C2005.46544%20L11615.9329%2C1527.47501%20L10740.4301%2C1527.47501%20L10740.4301%2C39.8517235%20L10260.0009%2C39.8517235%20L10260.0009%2C2005.46544%20Z%20M12094.5247%2C2007.90417%20L13450.4567%2C2007.90417%20L13450.4567%2C1529.91373%20L12597.9396%2C1529.91373%20L12597.9396%2C1261.6538%20L13252.9199%2C1261.6538%20L13252.9199%2C782.444002%20L12597.9396%2C782.444002%20L12597.9396%2C514.184066%20L13450.4567%2C514.184066%20L13450.4567%2C34.9742701%20L12094.5247%2C34.9742701%20L12094.5247%2C2007.90417%20Z%20M13929.0485%2C34.9742701%20L13929.0485%2C2005.46544%20L14409.4777%2C2005.46544%20L14409.4777%2C1279.70252%20L14977.7903%2C2003.78762%20L15544.7049%2C1279.93115%20L15544.7049%2C2005.46544%20L16025.1341%2C2005.46544%20L16025.1341%2C34.9742701%20L15926.5288%2C34.9742701%20L14977.7272%2C1284.31562%20L14027.6812%2C34.9742701%20L13929.0485%2C34.9742701%20Z%20M16809.1228%2C317.85585%20C17024.2535%2C122.786293%2017248.8045%2C24%2017549.892%2C24%20C17850.958%2C24%2018075.6198%2C122.844641%2018290.6207%2C317.79631%20C18494.3246%2C512.771795%2018597.3727%2C750.047518%2018597.3727%2C1023.77792%20C18597.3727%2C1298.25494%2018494.3282%2C1535.23059%2018290.4861%2C1728.71164%20C18076.2366%2C1921.3639%2017851.6856%2C2018.87844%2017549.8372%2C2018.87844%20C17247.2339%2C2018.0687%2017022.8162%2C1920.67682%2016809.2562%2C1728.65091%20C16606.2703%2C1534.30058%2016503.7259%2C1297.48331%2016503.7259%2C1023.77792%20C16503.7259%2C750.819147%2016606.275%2C513.698225%2016809.1228%2C317.85585%20Z%20M17927.6029%2C658.644089%20C17811.6395%2C557.420261%2017712.2733%2C508.087249%2017549.9027%2C508.087249%20C17384.7564%2C508.087249%2017285.177%2C557.502425%2017171.1332%2C658.452373%20C17054.9412%2C761.28257%2016998.4325%2C880.46343%2016998.4325%2C1021.39397%20C16998.4325%2C1163.93326%2017054.9924%2C1282.95574%2017170.9129%2C1384.14147%20C17285.8641%2C1484.48173%2017385.5923%2C1533.57301%2017549.9027%2C1533.57301%20C17711.4445%2C1533.57301%2017810.9465%2C1484.56509%2017927.8268%2C1383.94856%20C18044.4415%2C1283.56066%2018101.3741%2C1164.66083%2018101.3741%2C1021.39397%20C18101.3741%2C879.73586%2018044.4939%2C760.676461%2017927.6029%2C658.644089%20Z%20M19075.9645%2C34.9742701%20L19075.9645%2C2005.46544%20L19570.8629%2C2005.46544%20L19570.8629%2C973.498233%20L20718.8804%2C2005.46544%20L20826.9703%2C2005.46544%20L20826.9703%2C34.9742701%20L20330.7549%2C34.9742701%20L20330.7549%2C1069.38258%20L19179.9855%2C34.9742701%20L19075.9645%2C34.9742701%20Z%22%20id%3D%22su8erlemon%22%20fill%3D%22%23FBE400%22%3E%3C/path%3E%0A%20%20%20%20%20%20%20%20%3C/g%3E%0A%20%20%20%20%3C/g%3E%0A%3C/svg%3E";var E=new THREE.Texture;E.image=_,_.onload=function(){E.needsUpdate=!0};var M=new THREE.WebGLRenderTarget(1024,1024,{minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat}),T=new THREE.EffectComposer(C,M),L=new THREE.ShaderPass(THREE.DelayShader);T.addPass(L);var D=new THREE.WebGLRenderTarget(1024,1024,{minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat}),S=new THREE.EffectComposer(C,D),N=new THREE.ShaderPass(THREE.DelayShader2);S.addPass(N);var R=new THREE.EffectComposer(C),F=new THREE.RenderPass(z,h);R.addPass(F);var U=new THREE.ShaderPass(THREE.DelayShader3);U.renderToScreen=!0,R.addPass(U),console.log(L.uniforms),console.log(N.uniforms),console.log(U.uniforms),$(window).keypress(function(n){switch(H=6.28*Math.random(),!0){case 97==n.which:console.log("A!");var e=P.rotation.x,t=P.rotation.y,o=P.rotation.z;TweenMax.killTweensOf(P.rotation),TweenMax.to(P.rotation,1,{x:e,y:t+1.57,z:o,ease:Elastic.easeOut.config(1.2,.3)});break;case 115==n.which:console.log("S!"),TweenMax.killTweensOf(P.rotation),TweenMax.to(P.rotation,.5,{x:1,y:3,z:0,ease:Expo.easeOut});break;case 100==n.which:console.log("D!"),TweenMax.to(P.rotation,.5,{x:5*Math.random(),y:5*Math.random(),z:5*Math.random(),ease:Expo.easeOut})}}),$(window).on("resize",i);var I=0;i();var j=0,A=0;$(window).on("mousemove",function(n){j=n.clientX/$(window).width(),A=1-n.clientY/$(window).height()});var H=0;r()},{"./js/CircleBoxes":1,"./js/CirclePanels":2,"./js/DelayPass":3,"./js/DelayPass2":4,"./js/DelayPass3":5,"./js/LiquidSphere":6,"./js/LiquidSphere2":7,"./js/SkySphere":8,"./js/ThinLines":9,"./js/TubeLines":10,"./lib/createThree":11}],13:[function(n,e,t){e.exports=function(n){"string"==typeof n&&(n=[n]);for(var e=[].slice.call(arguments,1),t=[],o=0;o<n.length-1;o++)t.push(n[o],e[o]||"");return t.push(n[o]),t.join("")}},{}],14:[function(n,e,t){e.exports=function(n){function e(e,t){function o(){return 2*Math.PI/60/60*F.autoRotateSpeed}function i(){return Math.pow(.95,F.zoomSpeed)}function r(n){G.theta-=n}function a(n){G.phi-=n}function s(e){F.object instanceof n.PerspectiveCamera?V/=e:F.object instanceof n.OrthographicCamera?(F.object.zoom=Math.max(F.minZoom,Math.min(F.maxZoom,F.object.zoom*e)),F.object.updateProjectionMatrix(),Y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),F.enableZoom=!1)}function c(e){F.object instanceof n.PerspectiveCamera?V*=e:F.object instanceof n.OrthographicCamera?(F.object.zoom=Math.max(F.minZoom,Math.min(F.maxZoom,F.object.zoom/e)),F.object.updateProjectionMatrix(),Y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),F.enableZoom=!1)}function v(n){X.set(n.clientX,n.clientY)}function l(n){$.set(n.clientX,n.clientY)}function x(n){W.set(n.clientX,n.clientY)}function m(n){Z.set(n.clientX,n.clientY),B.subVectors(Z,X);var e=F.domElement===document?F.domElement.body:F.domElement;r(2*Math.PI*B.x/e.clientWidth*F.rotateSpeed),a(2*Math.PI*B.y/e.clientHeight*F.rotateSpeed),X.copy(Z),F.update()}function f(n){J.set(n.clientX,n.clientY),nn.subVectors(J,$),nn.y>0?s(i()):nn.y<0&&c(i()),$.copy(J),F.update()}function g(n){K.set(n.clientX,n.clientY),Q.subVectors(K,W),on(Q.x,Q.y),W.copy(K),F.update()}function p(n){}function u(n){n.deltaY<0?c(i()):n.deltaY>0&&s(i()),F.update()}function y(n){switch(n.keyCode){case F.keys.UP:on(0,F.keyPanSpeed),F.update();break;case F.keys.BOTTOM:on(0,-F.keyPanSpeed),F.update();break;case F.keys.LEFT:on(F.keyPanSpeed,0),F.update();break;case F.keys.RIGHT:on(-F.keyPanSpeed,0),F.update()}}function d(n){X.set(n.touches[0].pageX,n.touches[0].pageY)}function h(n){var e=n.touches[0].pageX-n.touches[1].pageX,t=n.touches[0].pageY-n.touches[1].pageY,o=Math.sqrt(e*e+t*t);$.set(0,o)}function z(n){W.set(n.touches[0].pageX,n.touches[0].pageY)}function C(n){Z.set(n.touches[0].pageX,n.touches[0].pageY),B.subVectors(Z,X);var e=F.domElement===document?F.domElement.body:F.domElement;r(2*Math.PI*B.x/e.clientWidth*F.rotateSpeed),a(2*Math.PI*B.y/e.clientHeight*F.rotateSpeed),X.copy(Z),F.update()}function w(n){var e=n.touches[0].pageX-n.touches[1].pageX,t=n.touches[0].pageY-n.touches[1].pageY,o=Math.sqrt(e*e+t*t);J.set(0,o),nn.subVectors(J,$),nn.y>0?c(i()):nn.y<0&&s(i()),$.copy(J),F.update()}function P(n){K.set(n.touches[0].pageX,n.touches[0].pageY),Q.subVectors(K,W),on(Q.x,Q.y),W.copy(K),F.update()}function b(n){}function _(n){if(!1!==F.enabled){if(n.preventDefault(),n.button===F.mouseButtons.ORBIT){if(!1===F.enableRotate)return;v(n),H=A.ROTATE}else if(n.button===F.mouseButtons.ZOOM){if(!1===F.enableZoom)return;l(n),H=A.DOLLY}else if(n.button===F.mouseButtons.PAN){if(!1===F.enablePan)return;x(n),H=A.PAN}H!==A.NONE&&(document.addEventListener("mousemove",E,!1),document.addEventListener("mouseup",M,!1),F.dispatchEvent(I))}}function E(n){if(!1!==F.enabled)if(n.preventDefault(),H===A.ROTATE){if(!1===F.enableRotate)return;m(n)}else if(H===A.DOLLY){if(!1===F.enableZoom)return;f(n)}else if(H===A.PAN){if(!1===F.enablePan)return;g(n)}}function M(n){!1!==F.enabled&&(p(n),document.removeEventListener("mousemove",E,!1),document.removeEventListener("mouseup",M,!1),F.dispatchEvent(j),H=A.NONE)}function T(n){!1===F.enabled||!1===F.enableZoom||H!==A.NONE&&H!==A.ROTATE||(n.preventDefault(),n.stopPropagation(),u(n),F.dispatchEvent(I),F.dispatchEvent(j))}function L(n){!1!==F.enabled&&!1!==F.enableKeys&&!1!==F.enablePan&&y(n)}function D(n){if(!1!==F.enabled){switch(n.touches.length){case 1:if(!1===F.enableRotate)return;d(n),H=A.TOUCH_ROTATE;break;case 2:if(!1===F.enableZoom)return;h(n),H=A.TOUCH_DOLLY;break;case 3:if(!1===F.enablePan)return;z(n),H=A.TOUCH_PAN;break;default:H=A.NONE}H!==A.NONE&&F.dispatchEvent(I)}}function S(n){if(!1!==F.enabled)switch(n.preventDefault(),n.stopPropagation(),n.touches.length){case 1:if(!1===F.enableRotate)return;if(H!==A.TOUCH_ROTATE)return;C(n);break;case 2:if(!1===F.enableZoom)return;if(H!==A.TOUCH_DOLLY)return;w(n);break;case 3:if(!1===F.enablePan)return;if(H!==A.TOUCH_PAN)return;P(n);break;default:H=A.NONE}}function N(n){!1!==F.enabled&&(b(n),F.dispatchEvent(j),H=A.NONE)}function R(n){n.preventDefault()}this.object=e,this.domElement=void 0!==t?t:document,this.enabled=!0,this.target=new n.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:n.MOUSE.LEFT,ZOOM:n.MOUSE.MIDDLE,PAN:n.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return k.phi},this.getAzimuthalAngle=function(){return k.theta},this.reset=function(){F.target.copy(F.target0),F.object.position.copy(F.position0),F.object.zoom=F.zoom0,F.object.updateProjectionMatrix(),F.dispatchEvent(U),F.update(),H=A.NONE},this.update=function(){var t=new n.Vector3,i=(new n.Quaternion).setFromUnitVectors(e.up,new n.Vector3(0,1,0)),a=i.clone().inverse(),s=new n.Vector3,c=new n.Quaternion;return function(){var n=F.object.position;return t.copy(n).sub(F.target),t.applyQuaternion(i),k.setFromVector3(t),F.autoRotate&&H===A.NONE&&r(o()),k.theta+=G.theta,k.phi+=G.phi,k.theta=Math.max(F.minAzimuthAngle,Math.min(F.maxAzimuthAngle,k.theta)),k.phi=Math.max(F.minPolarAngle,Math.min(F.maxPolarAngle,k.phi)),k.makeSafe(),k.radius*=V,k.radius=Math.max(F.minDistance,Math.min(F.maxDistance,k.radius)),F.target.add(q),t.setFromSpherical(k),t.applyQuaternion(a),n.copy(F.target).add(t),F.object.lookAt(F.target),!0===F.enableDamping?(G.theta*=1-F.dampingFactor,G.phi*=1-F.dampingFactor):G.set(0,0,0),V=1,q.set(0,0,0),!!(Y||s.distanceToSquared(F.object.position)>O||8*(1-c.dot(F.object.quaternion))>O)&&(F.dispatchEvent(U),s.copy(F.object.position),c.copy(F.object.quaternion),Y=!1,!0)}}(),this.dispose=function(){F.domElement.removeEventListener("contextmenu",R,!1),F.domElement.removeEventListener("mousedown",_,!1),F.domElement.removeEventListener("wheel",T,!1),F.domElement.removeEventListener("touchstart",D,!1),F.domElement.removeEventListener("touchend",N,!1),F.domElement.removeEventListener("touchmove",S,!1),
document.removeEventListener("mousemove",E,!1),document.removeEventListener("mouseup",M,!1),window.removeEventListener("keydown",L,!1)};var F=this,U={type:"change"},I={type:"start"},j={type:"end"},A={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},H=A.NONE,O=1e-6,k=new n.Spherical,G=new n.Spherical,V=1,q=new n.Vector3,Y=!1,X=new n.Vector2,Z=new n.Vector2,B=new n.Vector2,W=new n.Vector2,K=new n.Vector2,Q=new n.Vector2,$=new n.Vector2,J=new n.Vector2,nn=new n.Vector2,en=function(){var e=new n.Vector3;return function(n,t){e.setFromMatrixColumn(t,0),e.multiplyScalar(-n),q.add(e)}}(),tn=function(){var e=new n.Vector3;return function(n,t){e.setFromMatrixColumn(t,1),e.multiplyScalar(n),q.add(e)}}(),on=function(){var e=new n.Vector3;return function(t,o){var i=F.domElement===document?F.domElement.body:F.domElement;if(F.object instanceof n.PerspectiveCamera){var r=F.object.position;e.copy(r).sub(F.target);var a=e.length();a*=Math.tan(F.object.fov/2*Math.PI/180),en(2*t*a/i.clientHeight,F.object.matrix),tn(2*o*a/i.clientHeight,F.object.matrix)}else F.object instanceof n.OrthographicCamera?(en(t*(F.object.right-F.object.left)/F.object.zoom/i.clientWidth,F.object.matrix),tn(o*(F.object.top-F.object.bottom)/F.object.zoom/i.clientHeight,F.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),F.enablePan=!1)}}();F.domElement.addEventListener("contextmenu",R,!1),F.domElement.addEventListener("mousedown",_,!1),F.domElement.addEventListener("wheel",T,!1),F.domElement.addEventListener("touchstart",D,!1),F.domElement.addEventListener("touchend",N,!1),F.domElement.addEventListener("touchmove",S,!1),window.addEventListener("keydown",L,!1),this.update()}return e.prototype=Object.create(n.EventDispatcher.prototype),e.prototype.constructor=e,Object.defineProperties(e.prototype,{center:{get:function(){return console.warn("THREE.OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(n){console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!n}},noRotate:{get:function(){return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(n){console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!n}},noPan:{get:function(){return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(n){console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!n}},noKeys:{get:function(){return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(n){console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!n}},staticMoving:{get:function(){return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(n){console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!n}},dynamicDampingFactor:{get:function(){return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(n){console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=n}}}),e}},{}]},{},[12]);
