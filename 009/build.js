!function e(n,t,o){function a(r,c){if(!t[r]){if(!n[r]){var s="function"==typeof require&&require;if(!c&&s)return s(r,!0);if(i)return i(r,!0);var l=new Error("Cannot find module '"+r+"'");throw l.code="MODULE_NOT_FOUND",l}var u=t[r]={exports:{}};n[r][0].call(u.exports,function(e){var t=n[r][1][e];return a(t?t:e)},u,u.exports,e,n,t,o)}return t[r].exports}for(var i="function"==typeof require&&require,r=0;r<o.length;r++)a(o[r]);return a}({1:[function(e,n,t){"use strict";function o(){function e(){n=window.innerWidth,t=window.innerHeight,i&&(i.setSize(n,t),i.setViewport(0,0,n,t),c.aspect=n/t,c.updateProjectionMatrix())}var n,t;n=window.innerWidth,t=window.innerHeight;var o=Math.min(1.5,window.devicePixelRatio),i=new THREE.WebGLRenderer({canvas:document.getElementById("canvas"),antialias:!0});i.setClearColor(13421772,1),i.setSize(n,t),i.setPixelRatio(o);var r=new THREE.Scene,c=new THREE.PerspectiveCamera(60,n/t,1,1e3);c.position.set(0,1,-3),c.lookAt(new THREE.Vector3);var s=new a(c);return window.addEventListener("resize",e),{renderer:i,scene:r,controls:s,camera:c}}var a=e("three-orbit-controls")(THREE);n.exports=o},{"three-orbit-controls":4}],2:[function(e,n,t){"use strict";function o(){T.position.z=30,T.lookAt(new THREE.Vector3),a(),i()}function a(){p=new GPUComputationRenderer(N,N,M);var e=p.createTexture(),n=p.createTexture();r(e,n,y),f=p.addVariable("textureVelocity",j,n),x=p.addVariable("texturePosition",H,e),p.setVariableDependencies(f,[x,f]),p.setVariableDependencies(x,[x,f]),h=x.material.uniforms,b=f.material.uniforms,x.material.uniforms.time={value:0},f.material.uniforms.time={value:0},x.material.uniforms.texture1={type:"t",value:null},f.material.uniforms.texture1={type:"t",value:null},p.init()}function i(){function e(){var e={animation:!0,ik:!0,physics:!0,"show IK bones":!1},n=new dat.GUI;n.add(e,"animation").onChange(function(){d.doAnimation=e.animation}),n.add(e,"ik").onChange(function(){d.doIk=e.ik}),n.add(e,"physics").onChange(function(){d.enablePhysics(e.physics)}),n.add(e,"show IK bones").onChange(function(){m.visible=e["show IK bones"]})}v=new THREE.BufferGeometry;for(var n=new Float32Array(3*I),t=0;t<3*I;t+=9)n[t+0]=0,n[t+1]=0,n[t+2]=0,n[t+3]=0,n[t+4]=0,n[t+5]=0,n[t+6]=0,n[t+7]=0,n[t+8]=0;for(var o=new Float32Array(I),t=0;t<I;t++)o[t]=t;for(var a=new Float32Array(2*I),i=0,r=0;r<N;r++)for(var t=0;t<N;t++)a[i++]=t/(N-1),a[i++]=r/(N-1);v.addAttribute("position",new THREE.BufferAttribute(n,3)),v.addAttribute("uv",new THREE.BufferAttribute(a,2)),v.addAttribute("index2",new THREE.BufferAttribute(o,1)),g={texture1:{type:"t",value:null},texturePosition:{value:null},textureVelocity:{value:null},textureDance:{value:null},cameraConstant:{value:c(T)}};var s=new THREE.ShaderMaterial({uniforms:g,vertexShader:A,fragmentShader:L,side:THREE.DoubleSide,transparent:!0});s.extensions.drawBuffers=!0;var l=new THREE.Points(v,s);l.matrixAutoUpdate=!1,l.updateMatrix(),C.add(l);var p=function(e){if(e.lengthComputable){var n=e.loaded/e.total*100;console.log(Math.round(n,2)+"% downloaded")}},f=function(e){},x="models/mmd/miku/miku_v2.pmd",h=["models/mmd/vmds/wavefile_v2.vmd"];d=new THREE.MMDHelper;var b=new THREE.MMDLoader;b.load(x,h,function(n){console.log(n),console.log(n.isPoints=!0);for(var t=new Float32Array(n.geometry.attributes.position.count),o=0;o<n.geometry.attributes.position.count;o++)t[o]=o;n.geometry.addAttribute("index2",new THREE.BufferAttribute(t,1));for(var a=[],o=0,i=n.material.materials.length;o<i;o++){var r=new THREE.ShaderMaterial({vertexShader:R,fragmentShader:O,skinning:!0,wireframe:!0});a.push(r)}var c=new THREE.MultiMaterial(a);n.material=c,u=n,u.position.y=-12,V.add(u),d.add(u),d.setAnimation(u),m=new THREE.CCDIKHelper(u),m.visible=!1,C.add(m),E={texture1:{type:"t",value:null}};var s=new THREE.ShaderMaterial({uniforms:E,vertexShader:S,fragmentShader:z}),l=new THREE.Points(n.geometry,s);C.add(l),e()},p,f)}function r(e,n){var t=e.image.data,o=n.image.data;console.log("pos",t.length),console.log("vel",o.length);for(var a=0,i=t.length;a<i;a+=12){var r=200*Math.random()-100,c=200*Math.random()-100,s=200*Math.random()-100,l=10*Math.random();t[a+0]=r,t[a+1]=c,t[a+2]=s,t[a+3]=l,t[a+4]=r,t[a+5]=c,t[a+6]=s,t[a+7]=l,t[a+8]=r,t[a+9]=c,t[a+10]=s,t[a+11]=l;var u=0,d=0,m=-.03;l=.5+.5*Math.random(),o[a+0]=u,o[a+1]=d,o[a+2]=m,o[a+3]=l,o[a+4]=u,o[a+5]=d,o[a+6]=m,o[a+7]=l,o[a+8]=u,o[a+9]=d,o[a+10]=m,o[a+11]=l}}function c(e){return window.innerHeight/(Math.tan(.5*THREE.Math.DEG2RAD*e.fov)/e.zoom)}function s(){requestAnimationFrame(s),l()}function l(){d.animate(k.getDelta()),M.render(V,T,F),E&&(E.texture1.value=F.texture),U++,U>100&&(_+=1,U=0,_>10&&(_=0)),p.compute(),f.material.uniforms.time.value+=1/60,f.material.uniforms.texture1.value=F.texture,x.material.uniforms.texture1.value=F.texture,g.texture1.value=F.texture,g.texturePosition.value=p.getCurrentRenderTarget(x).texture,g.textureVelocity.value=p.getCurrentRenderTarget(f).texture,M.render(C,T)}var u,d,m,v,p,f,x,h,b,g,y,E,w=e("./lib/createThree"),P=w(),T=P.camera,C=P.scene,M=P.renderer,D=(P.controls,e("glslify")),O=D(["#define GLSLIFY 1\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\n//varying vec4 vPosition;\nvarying vec3 vColor;\n\nvoid main() {\n//  gl_FragColor = vec4(1.0,  // R\n//                      0.0,  // G\n//                      1.0,  // B\n//                      1.0); // A\n  gl_FragColor = vec4(vColor,1.0);\n}"]),R=D(["#define GLSLIFY 1\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n//   varying vec2 vUv;\n//    uniform mat4 bindMatrix;\n//    uniform mat4 bindMatrixInverse;\n//    uniform mat4 boneMatrices[ MAX_BONES ];\nuniform float offset;\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n\n//varying vec4 vPosition;\nvarying vec3 vColor;\nattribute float index2;\n\nconst float frag = 1.0 / 128.;\nconst float texShift = 0.5 * frag;\n\nvoid main() {\n\n  vec3 transformed = vec3(position + normal * offset);\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n\tvec4 mvPosition = modelViewMatrix * skinned;\n\n  vec4 pos1 = modelMatrix * skinned * 0.1;\n  //  vec4 pos1 = vec4(position,1.0);\n  //  vColor = ((normalize(pos1) + 1.0) * 0.5).xyz;\n  vColor = (1.0 + pos1.xyz) * 0.5;\n\n  float pu = fract(index2 * frag) * 2.0 - 1.0;\n  float pv = floor(index2 * frag) * frag * 2.0 - 1.0;\n  gl_Position = vec4(pu + texShift, pv + texShift, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n//  vPosition = skinned;\n  //gl_Position = projectionMatrix * mvPosition;\n\n }"]),z=D(["#define GLSLIFY 1\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform sampler2D texture1;\n\nvoid main() {\n\n//  gl_FragColor = texture2D( texture1, gl_PointCoord );\n  gl_FragColor = vec4(1.0,  // R\n                      0.0,  // G\n                      1.0,  // B\n                      1.0); // A\n\n//    gl_FragColor = vColor;\n}"]),S=D(["#define GLSLIFY 1\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n\nuniform sampler2D texture1;\n//varying vec4 vColor;\n\nattribute float index2;\nconst float frag = 1.0 / 128.0;\nconst float texShift = 0.5 * frag;\n\nvoid main() {\n\n    float pu = fract(index2 * frag + texShift);\n    float pv = floor(index2 * frag) * frag + texShift;\n    vec3 tPosition = texture2D(texture1, vec2(pu, pv)).rgb * 2.0 - 1.0;\n\n    gl_Position  = projectionMatrix * viewMatrix * vec4(tPosition, 1.0);\n    gl_PointSize = 2.0;\n\n}"]),L=D(["#define GLSLIFY 1\n// VertexShaderから受け取った色を格納するだけ。\nvarying vec4 vColor;\nvarying vec2 vUv;\nvoid main() {\n\n    vUv;\n\n    gl_FragColor = vColor;\n\n}"]),A=D(["#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D texturePosition;\nuniform float cameraConstant;\nuniform float density;\nvarying vec4 vColor;\nvarying vec2 vUv;\nuniform float radius;\n\n//uniform sampler2D texture1;\n////varying vec4 vColor;\n//\n//attribute float index2;\n//const float frag = 1.0 / 128.0;\n//const float texShift = 0.5 * frag;\n\nvoid main() {\n\n    vec4 posTemp = texture2D( texturePosition, uv );\n    vec3 pos = posTemp.xyz;\n    vColor = vec4( 63.0/255.0, 81.0/255.0, 100.0/255.0, 1.0 );\n\n    pos += position;\n\n//    float pu = fract(index2 * frag + texShift);\n//    float pv = floor(index2 * frag) * frag + texShift;\n//    vec3 tPosition = texture2D(texture1, vec2(pu, pv)).rgb * 2.0 - 1.0;\n\n//    pos = tPosition;\n\n    // ポイントのサイズを決定\n    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n    gl_PointSize = 2.0;//0.5 * cameraConstant / ( - mvPosition.z );\n\n    // uv情報の引き渡し\n    vUv = uv;\n\n    // 変換して格納\n    gl_Position = projectionMatrix * mvPosition;\n\n}"]),H=D(["#define GLSLIFY 1\n#define delta ( 1.0 / 60.0 )\n#define area 3.0\n\n//varying vec4 vColor;\n\nuniform sampler2D texture1;\n\n//attribute float index2;\n\nconst float frag = 1.0 / 128.0;\nconst float texShift = 0.5 * frag;\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec4 tmpPos = texture2D( texturePosition, uv );\n  vec4 tmpVel = texture2D( textureVelocity, uv );\n//  vec4 tmpDan = texture2D( textureDance, uv );\n\n  float index = uv.x * 128. * uv.y * 128.;\n  float pu = fract(index * frag + texShift);\n  float pv = floor(index * frag) * frag + texShift;\n//\n  vec3 tmpDan = texture2D( texture1, vec2(pu, pv)).rgb * 2.0 - 1.0;\n\n  vec3 pos = tmpPos.xyz;\n  vec3 vel = tmpVel.xyz;\n\n  // Dynamics\n  pos += vel;// * delta;\n//   pos = tmpDan;\n//  pos.x>area?pos=vec3(pos.x-area*2.0, pos.y         , pos.z         ):vec3(0.0);\n//  pos.y>area?pos=vec3(pos.x         , pos.y-area*2.0, pos.z         ):vec3(0.0);\n//  pos.z>area?pos=vec3(pos.x         , pos.y         , pos.z-area*2.0):vec3(0.0);\n//\n//  pos.x<-area?pos=vec3(pos.x+area*2.0, pos.y         , pos.z         ):vec3(0.0);\n//  pos.y<-area?pos=vec3(pos.x         , pos.y+area*2.0, pos.z         ):vec3(0.0);\n//  pos.z<-area?pos=vec3(pos.x         , pos.y         , pos.z+area*2.0):vec3(0.0);\n\n  pos.x>area?pos=tmpDan:vec3(0.0);\n  pos.y>area?pos=tmpDan:vec3(0.0);\n  pos.z>area?pos=tmpDan:vec3(0.0);\n\n  pos.x<-area?pos=tmpDan:vec3(0.0);\n  pos.y<-area?pos=tmpDan:vec3(0.0);\n  pos.z<-area?pos=tmpDan:vec3(0.0);\n\n  gl_FragColor = vec4( pos, tmpPos.w );\n\n}"]),j=D(["#define GLSLIFY 1\n// For PI declaration:\n#include <common>\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nuniform float time;\n\nfloat maxspeed = 5.0;\nfloat maxforce = 0.5;\n\nfloat speed = 0.4;\n\nfloat magSq(vec3 vec) {\n  return (vec.x*vec.x + vec.y*vec.y + vec.z*vec.z);\n}\n\nvec3 limit(vec3 vec, float max) {\n  if (magSq(vec) > max*max) {\n    vec = normalize(vec);\n    vec *= max;\n  }\n  return vec;\n}\n\nvoid main() {\n\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    float idParticle = uv.y * resolution.x + uv.x;\n\n    vec4 tmpVel = texture2D( textureVelocity, uv );\n    vec4 tmpPos = texture2D( texturePosition, uv );\n\n    gl_FragColor = vec4( tmpVel.xyz, tmpVel.w );\n}"]),k=new THREE.Clock,N=128,I=N*N,V=new THREE.Scene,F=new THREE.WebGLRenderTarget(128,128,{minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter});o(),s();var _=0,U=0},{"./lib/createThree":1,glslify:3}],3:[function(e,n,t){n.exports=function(e){"string"==typeof e&&(e=[e]);for(var n=[].slice.call(arguments,1),t=[],o=0;o<e.length-1;o++)t.push(e[o],n[o]||"");return t.push(e[o]),t.join("")}},{}],4:[function(e,n,t){n.exports=function(e){function n(n,t){function o(){return 2*Math.PI/60/60*H.autoRotateSpeed}function a(){return Math.pow(.95,H.zoomSpeed)}function i(e){U.theta-=e}function r(e){U.phi-=e}function c(n){H.object instanceof e.PerspectiveCamera?Y/=n:H.object instanceof e.OrthographicCamera?(H.object.zoom=Math.max(H.minZoom,Math.min(H.maxZoom,H.object.zoom*n)),H.object.updateProjectionMatrix(),G=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),H.enableZoom=!1)}function s(n){H.object instanceof e.PerspectiveCamera?Y*=n:H.object instanceof e.OrthographicCamera?(H.object.zoom=Math.max(H.minZoom,Math.min(H.maxZoom,H.object.zoom/n)),H.object.updateProjectionMatrix(),G=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),H.enableZoom=!1)}function l(e){Z.set(e.clientX,e.clientY)}function u(e){J.set(e.clientX,e.clientY)}function d(e){q.set(e.clientX,e.clientY)}function m(e){W.set(e.clientX,e.clientY),X.subVectors(W,Z);var n=H.domElement===document?H.domElement.body:H.domElement;i(2*Math.PI*X.x/n.clientWidth*H.rotateSpeed),r(2*Math.PI*X.y/n.clientHeight*H.rotateSpeed),Z.copy(W),H.update()}function v(e){$.set(e.clientX,e.clientY),ee.subVectors($,J),ee.y>0?c(a()):ee.y<0&&s(a()),J.copy($),H.update()}function p(e){K.set(e.clientX,e.clientY),Q.subVectors(K,q),oe(Q.x,Q.y),q.copy(K),H.update()}function f(e){}function x(e){e.deltaY<0?s(a()):e.deltaY>0&&c(a()),H.update()}function h(e){switch(e.keyCode){case H.keys.UP:oe(0,H.keyPanSpeed),H.update();break;case H.keys.BOTTOM:oe(0,-H.keyPanSpeed),H.update();break;case H.keys.LEFT:oe(H.keyPanSpeed,0),H.update();break;case H.keys.RIGHT:oe(-H.keyPanSpeed,0),H.update()}}function b(e){Z.set(e.touches[0].pageX,e.touches[0].pageY)}function g(e){var n=e.touches[0].pageX-e.touches[1].pageX,t=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(n*n+t*t);J.set(0,o)}function y(e){q.set(e.touches[0].pageX,e.touches[0].pageY)}function E(e){W.set(e.touches[0].pageX,e.touches[0].pageY),X.subVectors(W,Z);var n=H.domElement===document?H.domElement.body:H.domElement;i(2*Math.PI*X.x/n.clientWidth*H.rotateSpeed),r(2*Math.PI*X.y/n.clientHeight*H.rotateSpeed),Z.copy(W),H.update()}function w(e){var n=e.touches[0].pageX-e.touches[1].pageX,t=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(n*n+t*t);$.set(0,o),ee.subVectors($,J),ee.y>0?s(a()):ee.y<0&&c(a()),J.copy($),H.update()}function P(e){K.set(e.touches[0].pageX,e.touches[0].pageY),Q.subVectors(K,q),oe(Q.x,Q.y),q.copy(K),H.update()}function T(e){}function C(e){if(H.enabled!==!1){if(e.preventDefault(),e.button===H.mouseButtons.ORBIT){if(H.enableRotate===!1)return;l(e),V=I.ROTATE}else if(e.button===H.mouseButtons.ZOOM){if(H.enableZoom===!1)return;u(e),V=I.DOLLY}else if(e.button===H.mouseButtons.PAN){if(H.enablePan===!1)return;d(e),V=I.PAN}V!==I.NONE&&(document.addEventListener("mousemove",M,!1),document.addEventListener("mouseup",D,!1),H.dispatchEvent(k))}}function M(e){if(H.enabled!==!1)if(e.preventDefault(),V===I.ROTATE){if(H.enableRotate===!1)return;m(e)}else if(V===I.DOLLY){if(H.enableZoom===!1)return;v(e)}else if(V===I.PAN){if(H.enablePan===!1)return;p(e)}}function D(e){H.enabled!==!1&&(f(e),document.removeEventListener("mousemove",M,!1),document.removeEventListener("mouseup",D,!1),H.dispatchEvent(N),V=I.NONE)}function O(e){H.enabled===!1||H.enableZoom===!1||V!==I.NONE&&V!==I.ROTATE||(e.preventDefault(),e.stopPropagation(),x(e),H.dispatchEvent(k),H.dispatchEvent(N))}function R(e){H.enabled!==!1&&H.enableKeys!==!1&&H.enablePan!==!1&&h(e)}function z(e){if(H.enabled!==!1){switch(e.touches.length){case 1:if(H.enableRotate===!1)return;b(e),V=I.TOUCH_ROTATE;break;case 2:if(H.enableZoom===!1)return;g(e),V=I.TOUCH_DOLLY;break;case 3:if(H.enablePan===!1)return;y(e),V=I.TOUCH_PAN;break;default:V=I.NONE}V!==I.NONE&&H.dispatchEvent(k)}}function S(e){if(H.enabled!==!1)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:if(H.enableRotate===!1)return;if(V!==I.TOUCH_ROTATE)return;E(e);break;case 2:if(H.enableZoom===!1)return;if(V!==I.TOUCH_DOLLY)return;w(e);break;case 3:if(H.enablePan===!1)return;if(V!==I.TOUCH_PAN)return;P(e);break;default:V=I.NONE}}function L(e){H.enabled!==!1&&(T(e),H.dispatchEvent(N),V=I.NONE)}function A(e){e.preventDefault()}this.object=n,this.domElement=void 0!==t?t:document,this.enabled=!0,this.target=new e.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-(1/0),this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:e.MOUSE.LEFT,ZOOM:e.MOUSE.MIDDLE,PAN:e.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return _.phi},this.getAzimuthalAngle=function(){return _.theta},this.reset=function(){H.target.copy(H.target0),H.object.position.copy(H.position0),H.object.zoom=H.zoom0,H.object.updateProjectionMatrix(),H.dispatchEvent(j),H.update(),V=I.NONE},this.update=function(){var t=new e.Vector3,a=(new e.Quaternion).setFromUnitVectors(n.up,new e.Vector3(0,1,0)),r=a.clone().inverse(),c=new e.Vector3,s=new e.Quaternion;return function(){var e=H.object.position;return t.copy(e).sub(H.target),t.applyQuaternion(a),_.setFromVector3(t),H.autoRotate&&V===I.NONE&&i(o()),_.theta+=U.theta,_.phi+=U.phi,_.theta=Math.max(H.minAzimuthAngle,Math.min(H.maxAzimuthAngle,_.theta)),_.phi=Math.max(H.minPolarAngle,Math.min(H.maxPolarAngle,_.phi)),_.makeSafe(),_.radius*=Y,_.radius=Math.max(H.minDistance,Math.min(H.maxDistance,_.radius)),H.target.add(B),t.setFromSpherical(_),t.applyQuaternion(r),e.copy(H.target).add(t),H.object.lookAt(H.target),H.enableDamping===!0?(U.theta*=1-H.dampingFactor,U.phi*=1-H.dampingFactor):U.set(0,0,0),Y=1,B.set(0,0,0),!!(G||c.distanceToSquared(H.object.position)>F||8*(1-s.dot(H.object.quaternion))>F)&&(H.dispatchEvent(j),c.copy(H.object.position),s.copy(H.object.quaternion),G=!1,!0)}}(),this.dispose=function(){H.domElement.removeEventListener("contextmenu",A,!1),H.domElement.removeEventListener("mousedown",C,!1),H.domElement.removeEventListener("wheel",O,!1),H.domElement.removeEventListener("touchstart",z,!1),H.domElement.removeEventListener("touchend",L,!1),H.domElement.removeEventListener("touchmove",S,!1),document.removeEventListener("mousemove",M,!1),document.removeEventListener("mouseup",D,!1),window.removeEventListener("keydown",R,!1)};var H=this,j={type:"change"},k={type:"start"},N={type:"end"},I={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},V=I.NONE,F=1e-6,_=new e.Spherical,U=new e.Spherical,Y=1,B=new e.Vector3,G=!1,Z=new e.Vector2,W=new e.Vector2,X=new e.Vector2,q=new e.Vector2,K=new e.Vector2,Q=new e.Vector2,J=new e.Vector2,$=new e.Vector2,ee=new e.Vector2,ne=function(){var n=new e.Vector3;return function(e,t){n.setFromMatrixColumn(t,0),n.multiplyScalar(-e),B.add(n)}}(),te=function(){var n=new e.Vector3;return function(e,t){n.setFromMatrixColumn(t,1),n.multiplyScalar(e),B.add(n)}}(),oe=function(){var n=new e.Vector3;return function(t,o){var a=H.domElement===document?H.domElement.body:H.domElement;if(H.object instanceof e.PerspectiveCamera){var i=H.object.position;n.copy(i).sub(H.target);var r=n.length();r*=Math.tan(H.object.fov/2*Math.PI/180),ne(2*t*r/a.clientHeight,H.object.matrix),te(2*o*r/a.clientHeight,H.object.matrix)}else H.object instanceof e.OrthographicCamera?(ne(t*(H.object.right-H.object.left)/H.object.zoom/a.clientWidth,H.object.matrix),te(o*(H.object.top-H.object.bottom)/H.object.zoom/a.clientHeight,H.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),H.enablePan=!1)}}();H.domElement.addEventListener("contextmenu",A,!1),H.domElement.addEventListener("mousedown",C,!1),H.domElement.addEventListener("wheel",O,!1),H.domElement.addEventListener("touchstart",z,!1),H.domElement.addEventListener("touchend",L,!1),H.domElement.addEventListener("touchmove",S,!1),window.addEventListener("keydown",R,!1),this.update()}return n.prototype=Object.create(e.EventDispatcher.prototype),n.prototype.constructor=n,Object.defineProperties(n.prototype,{center:{get:function(){return console.warn("THREE.OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(e){console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!e}},noRotate:{get:function(){return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(e){console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!e}},noPan:{get:function(){return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(e){console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!e}},noKeys:{get:function(){return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(e){console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!e}},staticMoving:{get:function(){return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(e){console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!e}},dynamicDampingFactor:{get:function(){return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(e){console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=e}}}),n}},{}]},{},[2]);
